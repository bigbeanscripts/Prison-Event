-- ✅ Extra egg names you always want included
local extraEggNames = {
    "OrangeSpikedCrystal",
    "GemstoneSpiked",
    "TeddyBear",
    "ToyBeachBall",
}

local function getEggNames()
    local eggNamesSet = {}
    local zones = workspace:FindFirstChild("Zones")

    if zones then
        for _, world in pairs(zones:GetChildren()) do
            -- Only look at worlds with no numbers in their name
            if world:IsA("Folder") and not world.Name:match("%d") then
                local interactables = world:FindFirstChild("Interactables")
                if interactables then
                    local eggs = interactables:FindFirstChild("Eggs")
                    if eggs then
                        for _, egg in pairs(eggs:GetChildren()) do
                            if not egg.Name:lower():find("rewind") then
                                local name = egg.Name
                                name = name:gsub("%s*[Ee][Gg][Gg]%s*$", "") -- remove "Egg" at end
                                name = name:match("^%s*(.-)%s*$") -- trim spaces
                                eggNamesSet[name] = true
                            end
                        end
                    end
                end
            end
        end
    end

    -- ✅ Add all extra names from the table
    for _, extraName in ipairs(extraEggNames) do
        eggNamesSet[extraName] = true
    end

    -- Convert set to sorted list
    local eggNames = {}
    for name in pairs(eggNamesSet) do
        table.insert(eggNames, name)
    end
    table.sort(eggNames)

    return eggNames
end



loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()
local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()


local Window = Library:Window{
    Title = "Mining Event",
    SubTitle = "By Duckie",
    TabWidth = 160,
    Size =  UDim2.fromOffset(580, 460),
    Resize = false, 
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}


local Tabs = {
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
    AutoFight = Window:AddTab({ Title = "Main", Icon = "crown" }),
    Eggs = Window:AddTab({ Title = "Eggs", Icon = "egg" }),
    Tower = Window:AddTab({ Title = "Tower", Icon = "castle" }),
    Merchant = Window:AddTab({ Title = "Merchant", Icon = "phosphor-shopping-cart-fill" }),
    Wheel = Window:AddTab({ Title = "Miners Fortune Wheel", Icon = "ferris-wheel" }),
    Trial = Window:AddTab({ Title = "Trial", Icon = "trophy" }),
    Mining = Window:AddTab({ Title = "Mining", Icon = "pickaxe" }),
}



local PlaytimeSection = Tabs.AutoFight:AddSection("Playtime Pass")

local AutoPlaytimeToggle = PlaytimeSection:AddToggle("AutoPlaytime", {
    Title = "Auto Claim Playtime Pass",
    Default = false
})

AutoPlaytimeToggle:OnChanged(function()
    if AutoPlaytimeToggle.Value then
        -- Claim rewards immediately when enabled
        for i = 1, 12 do
            local args = {
                [1] = "Free",
                [2] = i
            }
            game:GetService("ReplicatedStorage").Packages.Knit.Services.EventPassService.RF.ClaimReward:InvokeServer(unpack(args))
        end
        
        -- Start reset/claim loop
        spawn(function()
            while AutoPlaytimeToggle.Value do
                wait(60) -- Wait before reset
                
                -- Reset pass
                game:GetService("ReplicatedStorage").Packages.Knit.Services.EventPassService.RF.Reset:InvokeServer()
                
                -- Claim all rewards after reset
                for i = 1, 12 do
                    local args = {
                        [1] = "Free",
                        [2] = i
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.EventPassService.RF.ClaimReward:InvokeServer(unpack(args))
                end
            end
        end)
    end
end)

local function GetCurrentZone()
    local player = game.Players.LocalPlayer

    -- Check player attributes first
    if player:GetAttribute("ZonePlayfulMines") then
        return "PlayfulMines"
    elseif player:GetAttribute("ZoneDesertMines") then
        return "DesertMines"
    elseif player:GetAttribute("ZoneMinersDreamland") then
        return "MinersDreamland"
    end

    -- Fallback: look through workspace zones
    local glassBridgeZone = workspace.Zones:FindFirstChild("DesertMines")
    if glassBridgeZone then return glassBridgeZone.Name end

    local frontmanZone = workspace.Zones:FindFirstChild("MinersDreamland")
    if frontmanZone then return frontmanZone.Name end

    return nil
end


local function GetValidZone(trainingType)
    local zone = GetCurrentZone()
    local fallback = "MinersDreamland"
    local replicatedStorage = game:GetService("ReplicatedStorage")

    local function hasData(moduleName)
        local success, module = pcall(function()
            return require(replicatedStorage.Data[moduleName])
        end)
        return success and module and (module[zone] or module[fallback])
    end

    if trainingType == "PunchBags" then
        if workspace.Zones:FindFirstChild(zone)
            and workspace.Zones[zone]:FindFirstChild("Interactables")
            and workspace.Zones[zone].Interactables:FindFirstChild("Training")
            and workspace.Zones[zone].Interactables.Training:FindFirstChild("PunchBags") then
            return zone
        elseif workspace.Zones:FindFirstChild(fallback)
            and workspace.Zones[fallback]:FindFirstChild("Interactables")
            and workspace.Zones[fallback].Interactables:FindFirstChild("Training")
            and workspace.Zones[fallback].Interactables.Training:FindFirstChild("PunchBags") then
            return fallback
        else
            return fallback
        end
    elseif trainingType == "Dumbells" then
        return hasData("Dumbells") and (hasData("Dumbells")[zone] and zone or fallback) or fallback
    elseif trainingType == "Grips" then
        return hasData("Grips") and (hasData("Grips")[zone] and zone or fallback) or fallback
    elseif trainingType == "Barbells" then
        return hasData("Barbells") and (hasData("Barbells")[zone] and zone or fallback) or fallback
    end

    return fallback
end


local function GetBestDuckBag()
    local player = game.Players.LocalPlayer
    local currentZone = GetValidZone(currentTrainingType)
    local fallbackZone = "MinersDreamland"

    if not currentZone then
        return "Tier1"
    end

    local knuckleStrength = player:GetAttribute("TotalBrainrotKnuckles") or 0
    local punchBagData = require(game:GetService("ReplicatedStorage").Data.PunchBags)

    if player:GetAttribute("VIP") == true then
        return "VIP"
    end

    local zoneList = { currentZone, fallbackZone }

    for _, zone in ipairs(zoneList) do
        local bestTier = "Tier1"
        local highestRequired = 0

        if punchBagData and punchBagData[zone] then
            for tier, data in pairs(punchBagData[zone]) do
                if data.StrengthRequired and
                   knuckleStrength >= data.StrengthRequired and
                   data.StrengthRequired > highestRequired then
                    bestTier = tier
                    highestRequired = data.StrengthRequired
                end
            end
            -- Return best tier found in this zone
            return bestTier
        end
    end
end


local function GetBestDuckEquipment(equipmentType)
    local player = game.Players.LocalPlayer
    local currentZone = GetCurrentZone()
    local fallbackZone = "MinersDreamland"

    if not currentZone then
        return { equipment = fallbackZone .. "1", zone = fallbackZone }
    end

    -- Determine attribute and data module based on type
    local dataModule
    local attrMap = {
        Dumbells = "TotalMiningBicep",
        Grips = "TotalMiningGrip",
        Barbells = "TotalMiningBicep"
    }

    if equipmentType ~= "Dumbells" and equipmentType ~= "Grips" and equipmentType ~= "Barbells" then
        equipmentType = "Dumbells"
    end

    dataModule = equipmentType
    local equipmentData

    pcall(function()
        equipmentData = require(game:GetService("ReplicatedStorage").Data[dataModule])
    end)

    if not equipmentData then
        return { equipment = fallbackZone .. "1", zone = fallbackZone }
    end

    -- Zone priority list
    local zoneList = { currentZone, fallbackZone }

    for _, zone in ipairs(zoneList) do
        local defaultEquipment = zone .. "1"
        local bestEquipment = defaultEquipment
        local highestRequired = 0

        -- Use the correct attribute for fallback zone too
        local statValue = player:GetAttribute(attrMap[equipmentType]) or 0

        if equipmentData[zone] then
            for name, data in pairs(equipmentData[zone]) do
                if data.StrengthRequired and 
                   statValue >= data.StrengthRequired and 
                   data.StrengthRequired > highestRequired then
                    bestEquipment = name
                    highestRequired = data.StrengthRequired
                end
            end
            return { equipment = bestEquipment, zone = zone }
        end
    end

    return { equipment = fallbackZone .. "1", zone = fallbackZone }
end

    

-- Add Training Section
local TrainSection = Tabs.AutoFight:AddSection("Auto Train")

local TrainingDropdown = Tabs.AutoFight:AddDropdown("TrainingSelect", {
    Title = "Select Training Type",
    Values = {"Dumbells", "PunchBags", "Grips", "Barbells"}, 
    Multi = false,
    Default = "Dumbells"
})

local AutoTrainToggle = Tabs.AutoFight:AddToggle("AutoTrain", {
    Title = "Auto Train",
    Description = "If this gets an error, turn the toggle off and on again. It occurs when you switch training types with the toggle on :)",
    Default = false
})

-- Variable to store the current training equipment type
local currentTrainingType = nil

AutoTrainToggle:OnChanged(function()
    if AutoTrainToggle.Value then
        -- Store the selected training type when starting
        currentTrainingType = TrainingDropdown.Value
        
        spawn(function()
            local currentZone = GetCurrentZone()
            
            if not currentZone then
                return
            end
            
            if currentTrainingType == "Dumbells" then
                -- Function to equip Dumbells
                local function equipDumbells()
                    local result = GetBestDuckEquipment("Dumbells")
                    local equipment = result.equipment
                    local equipZone = result.zone
                    local args = {
                        [1] = equipZone,
                        [2] = "Dumbells", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipDumbells()

                -- Click loop (every 0.6 seconds for Dumbells)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.6)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" then
                        equipDumbells()
                    end
                end
                
            elseif currentTrainingType == "Grips" then
                -- Function to equip Grips
                local function equipGrips()
                    local result = GetBestDuckEquipment("Grips")
                    local equipment = result.equipment
                    local equipZone = result.zone
                    local args = {
                        [1] = equipZone,
                        [2] = "Grips", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipGrips()

                -- Click loop (every 0.6 seconds for Grips)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.6)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" then
                        equipGrips()
                    end
                end
                
            elseif currentTrainingType == "Barbells" then
                -- Function to equip Barbells
                local function equipBarbells()
                    local result = GetBestDuckEquipment("Barbells")
                    local equipment = result.equipment
                    local equipZone = result.zone
                    local args = {
                        [1] = equipZone,
                        [2] = "Barbells", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipBarbells()

                -- Click loop (every 1.55 seconds for Barbells)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(1.55)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" then
                        equipBarbells()
                    end
                end
            elseif currentTrainingType == "Pull up bar" then
                -- Add Pull up bar handling
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Pull up bar" and TrainingDropdown.Value == "Pull up bar" do
                        local statsArgs = {
                            [1] = "17",
                            [2] = "Tier4"
                        }
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.PullupBarService.RE.onGiveStats:FireServer(unpack(statsArgs))
                        wait(1.55) -- Pull up bar every 1.55 seconds
                    end
                end)
            else -- PunchBags
                spawn(function() 
                    local lastTeleport = 0
                    while AutoTrainToggle.Value and currentTrainingType == "PunchBags" and TrainingDropdown.Value == "PunchBags" do
                        local tier = GetBestDuckBag()
                        local validZone = GetValidZone("PunchBags")
                        
                        -- Try to get the bag from workspace using the valid zone
                        local bag = workspace.Zones[validZone].Interactables.Training.PunchBags:FindFirstChild(tier)
                        
                        if bag then
                            -- Only teleport every 5 seconds
                            local currentTime = tick()
                            if currentTime - lastTeleport >= 5 then
                                local bagCFrame = bag:GetPivot()
                                game.Players.LocalPlayer.Character:PivotTo(bagCFrame * CFrame.new(0, 0, -5))
                                lastTeleport = currentTime
                            end
                            
                            -- Use the punch bag service every 0.2 seconds for knuckles (punch bags)
                            local args = {
                                [1] = validZone,
                                [2] = tier,
                                [3] = game.Players.LocalPlayer:GetAttribute("VIP") == true
                            }
                            game:GetService("ReplicatedStorage").Packages.Knit.Services.PunchBagService.RE.onGiveStats:FireServer(unpack(args))
                        end
                        wait(0.2)
                    end
                end)
            end
        end)
    else
        -- Clear the current training type when stopping
        currentTrainingType = nil
    end
end)

TrainingDropdown:OnChanged(function()
    if AutoTrainToggle.Value then
        AutoTrainToggle:SetValue(false) -- Turn off current training
        wait(0.1) -- Short delay to ensure loops are terminated
        AutoTrainToggle:SetValue(true) -- Turn on with new selection
    end
end)


-- UI section
local FightSection = Tabs.AutoFight:AddSection("Auto Fight")

local npcLocations = {
    MinersDreamland = workspace.GameObjects.ArmWrestling.MinersDreamland.NPC,
    DesertMines = workspace.GameObjects.ArmWrestling.DesertMines.NPC,
    PlayfulMines = workspace.GameObjects.ArmWrestling.PlayfulMines.NPC

}

local modelNames = {}

-- Gather NPC names from all locations
for _, path in pairs(npcLocations) do
    for _, npc in pairs(path:GetChildren()) do
        if npc:IsA("Model") then
            table.insert(modelNames, npc.Name)
        end
    end
end

table.sort(modelNames)

-- Dropdown
local modelDropdown = Tabs.AutoFight:AddDropdown("ModelDropdown", {
    Title = "Select Boss",
    Values = modelNames,
    Multi = false,
    Searchable = true,
    Default = modelNames[1] or "",
})

-- Auto Click toggle
local AutoClickToggle = Tabs.AutoFight:AddToggle("AutoClick", {
    Title = "Auto Click/Crit",
    Description = "Allows you to win fights over 5x as fast.",
    Default = false
})

-- Auto Fight toggle
local AutoFightToggle = Tabs.AutoFight:AddToggle("AutoFight", {
    Title = "Auto Fight",
    Description = "Automatically starts fights with the selected boss (to beat bosses much faster, enable the Auto Click/Crit toggle).",
    Default = false
})

-- Block the GameAnalyticsError remote event from firing (run once at startup)
pcall(function()
    local gameAnalyticsError = game:GetService("ReplicatedStorage"):FindFirstChild("GameAnalyticsError")
    if gameAnalyticsError then
        gameAnalyticsError.FireServer = function(self, ...)
            return
        end
    end
end)


local AlwaysWin = Tabs.AutoFight:AddButton({
    Title = "Always Win",
    Description = "This makes it impossible to lose, rejoining resets this.",
    Callback = function()
        coroutine.resume(coroutine.create(function()
            local armWrestle = require(game:GetService("ReplicatedStorage").Controllers.Fighting.ArmWrestleController)
            
            -- Method 1: Hook the IncrementPower function
            local originalIncrementPower = armWrestle.IncrementPower
            armWrestle.IncrementPower = function(self, amount)
                -- Always increment by a large positive amount
                originalIncrementPower(self, math.abs(amount or 1) * 1000)
            end
            
            -- Method 2: Continuously set health to max (more reliable)
            spawn(function()
                while armWrestle.Fighting do
                    if armWrestle.Health and armWrestle.MaxHealth then
                        armWrestle.Health = armWrestle.MaxHealth
                    end
                    wait(0.1)
                end
            end)
            
            -- Method 3: Override the UpdateFight function to prevent NPC power
            local originalUpdateFight = armWrestle.UpdateFight
            armWrestle.UpdateFight = function(self)
                -- Do nothing - prevents NPC from gaining power
            end
            
        end))
    end
})



local notefight = Tabs.AutoFight:Paragraph("Note", {
    Title = "Note",
    Content = "If you get an error when you turn the toggles on, try turning them off and on again, this wont effect anything. Furthermore, the speeds in which you win, is further increased if you launch the script twice (Open it enable the toggles, disable them, and then re-execute the script.) ",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Services
local KnitServices = game:GetService("ReplicatedStorage").Packages.Knit.Services
local ArmwrestleServiceRF = KnitServices:WaitForChild("ArmWrestleService"):WaitForChild("RF")
local ZoneService = KnitServices:WaitForChild("ZoneService"):WaitForChild("RE")

-- Variables
local autoClickThreads = {}
local autoFightThreads = {}
local cleanupConnections = {}
local lastZoneCheck = 0

-- Function to teleport to the correct zone for an NPC
local function teleportToNpcZone(npcName)
    local player = game.Players.LocalPlayer
    local playerCurrentZone = player:GetAttribute("CurrentZone")
    
    -- Find which zone the NPC is in
    local npcZone = nil
    for zoneName, path in pairs(npcLocations) do
        if path:FindFirstChild(npcName) then
            npcZone = zoneName == "MinersDreamland" and "MinersDreamland" or zoneName
            break
        end
    end
    
    -- If NPC zone found and different from current zone, teleport
    if npcZone and playerCurrentZone ~= npcZone then
        -- Get the teleport destination
        local teleportDest = workspace.Zones[npcZone].Interactables.Teleports.Locations.Spawn
        
        if teleportDest then
            -- Teleport to the appropriate zone
            local args = {
                [1] = teleportDest
            }
            
            ZoneService.teleport:FireServer(unpack(args))
            
            -- Wait for teleport to complete
            task.wait(2.5)

            return true
        end
    end
    return npcZone ~= nil
end

-- Cleanup function to clear pending requests
local function cleanupRequests()
    -- Get memory info before cleanup
    local memoryBefore = gcinfo()
    
    -- Force garbage collection to clear pending requests
    collectgarbage("count")
    
    -- Get memory info after cleanup
    local memoryAfter = gcinfo()
    
    pcall(function()
        -- Clear any pending remote calls by briefly disconnecting
        local temp = ArmwrestleServiceRF
        task.wait(0.01)
    end)
end

-- Auto Click toggle handler
AutoClickToggle:OnChanged(function()
    if AutoClickToggle.Value then
        -- Spawn new click threads
        task.spawn(function()
            for i = 1, 500 do
                local threadData = { active = true }
                table.insert(autoClickThreads, threadData)
                
                task.spawn(function()
                    while threadData.active and AutoClickToggle.Value do
                        pcall(function()
                            ArmwrestleServiceRF:WaitForChild("RequestClick"):InvokeServer()
                            ArmwrestleServiceRF:WaitForChild("RequestCritHit"):InvokeServer()
                        end)
                        task.wait()
                    end
                end)
                
                task.wait(0.001) -- Small delay between thread spawns to prevent all spawning at once
            end
        end)
        
        -- Start cleanup timer for auto click
        cleanupConnections.autoClick = task.spawn(function()
            while AutoClickToggle.Value do
                task.wait(5) -- Wait 5 seconds
                if AutoClickToggle.Value then
                    cleanupRequests()
                end
            end
        end)
    end
end)

-- Auto Fight toggle handler
AutoFightToggle:OnChanged(function()
    if AutoFightToggle.Value then
        -- First try to teleport to correct zone if needed
        local selectedName = modelDropdown.Value
        teleportToNpcZone(selectedName)
        
        -- Spawn threads for repeated boss fights
        for i = 1, 500 do
            local threadFlag = { active = true }
            table.insert(autoFightThreads, threadFlag)
            
            task.spawn(function()
                while threadFlag.active and AutoFightToggle.Value do
                    local selectedName = modelDropdown.Value
                    if selectedName then
                        -- Check if we need to teleport (periodically)
                        local currentTime = tick()
                        if currentTime - lastZoneCheck > 10 then
                            teleportToNpcZone(selectedName)
                            lastZoneCheck = currentTime
                        end
                        
                        -- Request fight with selected NPC
                        local args = {
                            [1] = selectedName
                        }
                        
                        pcall(function()
                            ArmwrestleServiceRF:WaitForChild("RequestStartFight"):InvokeServer(unpack(args))
                        end)
                    end
                    task.wait(0.01)
                end
            end)
            
            task.wait(0.001) -- Small delay between thread spawns
        end
        
        -- Start cleanup timer for auto fight
        cleanupConnections.autoFight = task.spawn(function()
            while AutoFightToggle.Value do
                task.wait(5) -- Wait 5 seconds
                if AutoFightToggle.Value then
                    cleanupRequests()
                end
            end
        end)
    end
end)

-- Add zone check when dropdown selection changes
modelDropdown:OnChanged(function()
    if AutoFightToggle.Value then
        local selectedName = modelDropdown.Value
        teleportToNpcZone(selectedName)
        lastZoneCheck = tick()
    end
end)

local function aggressiveCleanup()
    -- Get memory info before cleanup
    local memoryBefore = gcinfo()
    
    -- Method 1: Force disconnect and reconnect to service
    pcall(function()
        local oldService = ArmwrestleServiceRF
        ArmwrestleServiceRF = KnitServices:WaitForChild("ArmWrestleService"):WaitForChild("RF")
    end)
    
    -- Method 2: Clear all pending coroutines
    collectgarbage("count")
    
    -- Method 3: Brief pause to let network catch up
    task.wait(0.1)
    
    -- Get memory info after cleanup
    local memoryAfter = gcinfo()  
end

local EggSection = Tabs.Eggs:AddSection("Eggs")

-- Hatch Amount Dropdown
local HatchAmountDropdown = Tabs.Eggs:AddDropdown("HatchAmount", {
    Title = "Hatch Amount",
    Values = {"1x", "3x", "8x", "30x", "Max"},
    Multi = false,
    Default = "1x"
})

-- Egg Selection Dropdown (Populated Dynamically)
local eggNames = getEggNames()
local EggDropdown = Tabs.Eggs:AddDropdown("EggSelect", {
    Title = "Select Egg",
    Values = eggNames,
    Multi = false,
    Default = eggNames[1] or "None"
})

-- Auto Hatch Toggle
local AutoHatchToggle = Tabs.Eggs:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Default = false
})

AutoHatchToggle:OnChanged(function()
    if AutoHatchToggle.Value then
        spawn(function()
            while AutoHatchToggle.Value do
                local selectedEgg = EggDropdown.Value
                local hatchMultiplier = HatchAmountDropdown.Value

                local args = {}

                if hatchMultiplier == "1x" then
                    args = {selectedEgg, nil, nil, false, nil}
                elseif hatchMultiplier == "3x" then
                    args = {selectedEgg, nil, true, false}
                elseif hatchMultiplier == "8x" then
                    args = {selectedEgg, nil, false, true, true}
                elseif hatchMultiplier == "30x" or hatchMultiplier == "Max" then
                    args = {selectedEgg, nil, nil, false, nil, true}
                end

                -- Invoke server call to hatch egg
                game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))

                wait(0.25)
            end
        end)
    end
end)

local TowerSection = Tabs.Tower:AddSection("Mining Tower")

-- Prison Cave Buttons
TowerSection:AddButton({
    Title = "Use Mining Keys (1x)",
    Description = "Use the Mining Key once.",
    Callback = function()
        local args = {
            [1] = "MiningTower",
            [2] = false
        }
        game:GetService("ReplicatedStorage").Packages.Knit.Services.TowerService.RF.EnterTower:InvokeServer(unpack(args))
    end
})

TowerSection:AddButton({
    Title = "Use All Mining Keys (250x)",
    Description = "Use All Mining Keys (max 250 at a time).",
    Callback = function()
        local args = {
            [1] = "MiningTower",
            [2] = true
        }
        game:GetService("ReplicatedStorage").Packages.Knit.Services.TowerService.RF.EnterTower:InvokeServer(unpack(args))
    end
})



-- Create SuperRB Section
local EventSection = Tabs.Merchant:AddSection("Individual Items")

-- Add Load Script Button
EventSection:AddButton({
    Title = "Load better Merchant script",
    Description = "This allows you to select individual items, but MAY cause lag.",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/SeperateMerchant/refs/heads/main/LessLag"))()
    end
})

local MerchantSection = Tabs.Merchant:AddSection("Mining Merchant")

local BlackMarketDropdown = Tabs.Merchant:AddDropdown("BlackMarketDropdown", {
    Title = "Select Merchant Slot(s)",
    Values = {1, 2, 3, 4, 5},
    Multi = true,
    Default = {}
})

local AutoBuyToggle = Tabs.Merchant:AddToggle("AutoBuyToggle", {
    Title = "Auto Buy (Selected Slots)",
    Default = false
})

AutoBuyToggle:OnChanged(function()
    if AutoBuyToggle.Value then
        spawn(function()
            while true do
                if not AutoBuyToggle.Value then break end
                -- Buy 3 times
                for i = 1, 3 do
                    for number, isSelected in pairs(BlackMarketDropdown.Value) do
                        if isSelected then
                            local args = {
                                [1] = "Mining Merchant",
                                [2] = number
                            }
                            game:GetService("ReplicatedStorage").Packages.Knit.Services.LimitedMerchantService.RF.BuyItem:InvokeServer(unpack(args))
                            wait(1)
                        end
                    end
                end
                wait(30) -- Wait 30 seconds before next cycle
            end
        end)
    end
end)

local minersfortune = Tabs.Wheel:AddSection("Mines Fortune")


local GhostFortuneSpinDropdown = Tabs.Wheel:AddDropdown("GhostFortuneSpinAmount", {
    Title = "Spin Amount",
    Description = "Select Wheel Spin Amount",
    Values = {"1x", "3x", "10x"},
    Multi = false,
    Default = "1x"
})

local AutoGhostFortuneToggle = Tabs.Wheel:AddToggle("AutoGhostFortuneSpin", {
    Title = "Auto spin Miners Fortune wheel",
    Default = false
})

AutoGhostFortuneToggle:OnChanged(function()
    if AutoGhostFortuneToggle.Value then
        spawn(function()
            while true do
                if not AutoGhostFortuneToggle.Value then break end
                
                local args = {
                    [1] = "Miners Fortune",
                    [2] = GhostFortuneSpinDropdown.Value == "3x" and "x10" or GhostFortuneSpinDropdown.Value == "10x" and "x25" or nil
                }
                game:GetService("ReplicatedStorage").Packages.Knit.Services.SpinnerService.RF.Spin:InvokeServer(unpack(args))
                
                wait(1)
            end
        end)
    end
end)

local DragonTrialSection = Tabs.Trial:AddSection("Medieval Trial")
-- Auto join trial toggle
local AutoDragonTrialToggle = DragonTrialSection:AddToggle("AutoDragonTrial", {
    Title = "Auto Join Medieval Trial",
    Description = "Temporarily disables Auto Fight/Click. Re-enables them after trial ends.",
    Default = false
})

-- Crit & Click Threads Control
local RequestCritHit = KnitServices:WaitForChild("ArmWrestleService"):WaitForChild("RF"):WaitForChild("RequestCritHit")
local critThreads = {}
local critLoopRunning = false

-- Start Crit Threads
local function startCritThreads()
    if critLoopRunning then return end
    critLoopRunning = true

    for i = 1, 10 do
        local threadIndex = i
        critThreads[threadIndex] = true

        task.spawn(function()
            while critThreads[threadIndex] and AutoDragonTrialToggle.Value do
                pcall(function()
                    RequestCritHit:InvokeServer()
                end)
                task.wait(0.1) -- Spam crits every 0.1 seconds
            end
        end)
    end
end

-- Stop Crit Threads
local function stopCritThreads()
    critLoopRunning = false
    for i = 1, #critThreads do
        critThreads[i] = false
    end
    critThreads = {}
end

-- ✅ UPDATED: Teleport function now dynamically checks ALL zones
local function teleportToSelectedNPCZone()
    local selectedNPC = modelDropdown.Value
    if not selectedNPC then return end

    local targetTeleportPart = nil
    local armWrestlingRoot = workspace.GameObjects.ArmWrestling

    -- Loop through all folders (zones) inside the ArmWrestling folder
    for _, zoneFolder in ipairs(armWrestlingRoot:GetChildren()) do
        if zoneFolder:IsA("Model") and zoneFolder:FindFirstChild("NPC") then
            -- Check if the selected NPC exists in this zone
            if zoneFolder.NPC:FindFirstChild(selectedNPC) then
                -- Found it! Now find the corresponding teleport location in the main Zones folder
                local mainZone = workspace.Zones:FindFirstChild(zoneFolder.Name)
                if mainZone then
                    targetTeleportPart = mainZone:FindFirstChild("Interactables", true):FindFirstChild("Teleports", true):FindFirstChild("Locations", true):FindFirstChild("Spawn")
                    break -- Exit the loop since we found our target
                end
            end
        end
    end
    
    -- Teleport to the determined zone if a valid location was found
    if targetTeleportPart then
        pcall(function()
            local args = { [1] = targetTeleportPart }
            game:GetService("ReplicatedStorage").Packages.Knit.Services.ZoneService.RE.teleport:FireServer(unpack(args))
        end)
    else
        warn("Could not find a teleport location for NPC:", selectedNPC)
    end
end
-- Main Toggle Logic
AutoDragonTrialToggle:OnChanged(function()
    if AutoDragonTrialToggle.Value then
        spawn(function()
            -- Initialize state variables for this session
            local player = game.Players.LocalPlayer
            local lastJoinAttemptTime = 0
            local togglesDisabled = false
            local wasAutoFightOn = false
            local wasAutoClickOn = false

            while AutoDragonTrialToggle.Value do
                local success, timerGui = pcall(function()
                    return player.PlayerGui.Misc.Trials.Timer.Medieval.Timer
                end)

                if success and timerGui then
                    if timerGui.Text == "Ready!" then
                        -- Cooldown to prevent spamming joins after a trial ends
                        if os.time() - lastJoinAttemptTime < 180 then
                            wait(1)
                            continue 
                        end

                        -- Disable other auto-farm toggles before joining
                        if not togglesDisabled then
                            wasAutoFightOn = AutoFightToggle and AutoFightToggle.Value or false
                            wasAutoClickOn = AutoClickToggle and AutoClickToggle.Value or false

                            if wasAutoFightOn then AutoFightToggle:SetValue(false) end
                            if wasAutoClickOn then AutoClickToggle:SetValue(false) end
                            
                            togglesDisabled = true
                            wait(1) -- Wait for toggles to fully disable

                            -- ✅ TELEPORT TO TRIAL ZONE
                            pcall(function()
                                local trialTeleportLocation = workspace.Zones:FindFirstChild("13")
                                if trialTeleportLocation then
                                    local spawnLocation = trialTeleportLocation:FindFirstChild("Interactables", true):FindFirstChild("Teleports", true):FindFirstChild("Locations", true):FindFirstChild("Spawn")
                                    if spawnLocation then
                                        local teleportArgs = { [1] = spawnLocation }
                                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ZoneService.RE.teleport:FireServer(unpack(teleportArgs))
                                    end
                                end
                            end)
                            
                            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
                            local ArmWrestleService = Knit.GetService("ArmWrestleService")

                            ArmWrestleService:RequestEndFight("SkipEnd")

                            task.wait(2)
                        end

                        -- Join the Medieval trial and start spamming crits
                        local args = { "Medieval" }
                        KnitServices.ChampionshipService.RF.RequestJoin:InvokeServer(unpack(args))
                        startCritThreads()
                        lastJoinAttemptTime = os.time()

                    else -- Trial is active, over, or not available
                        stopCritThreads()

                        -- If we previously disabled the toggles, it's time to re-enable them
                        if togglesDisabled then
                            wait(2) -- Wait a bit after the trial ends

                            -- Teleport back to the selected NPC zone
                            teleportToSelectedNPCZone()
                            wait(3) -- Wait for teleport to complete

                            -- Re-enable toggles if they were on before
                            if wasAutoFightOn and AutoFightToggle then AutoFightToggle:SetValue(true) end
                            if wasAutoClickOn and AutoClickToggle then AutoClickToggle:SetValue(true) end

                            -- Reset state flags for the next cycle
                            wasAutoFightOn = false
                            wasAutoClickOn = false
                            togglesDisabled = false
                        end
                    end
                end
                wait(1)
            end
        end)
    else
        -- Cleanly stop crit threads when the toggle is turned off manually
        stopCritThreads()
    end
end)

-- Get necessary services and controllers
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Packages.Knit)

-- We need to wait for Knit to be started and all controllers to be available
local ArmWrestleController -- We need the ArmWrestleController for its MouseClick method
local AutoFightController
local AutoUIController
repeat
    task.wait()
    ArmWrestleController = Knit.GetController("ArmWrestleController", true)
    AutoFightController = Knit.GetController("AutoFightController", true)
    AutoUIController = Knit.GetController("AutoUIController", true)
until ArmWrestleController and AutoFightController and AutoUIController

-- A variable to store the game's original CPS value so we can restore it
local originalClicksPerSec = nil
local customAutoClickActive = false

-- Create toggle
local CustomMatchToggle = DragonTrialSection:AddToggle("NativeAutoFight", {
    Title = "Trial Auto Click",
    Description = "This will click for you during the trial. This works in the main game as well, but not nearly as fast as the Auto Click/Crit toggle.",
    Default = false
})

local function performCustomClicks()
    while customAutoClickActive do
        if ArmWrestleController.Fighting and ArmWrestleController.IsStarted then
            ArmWrestleController.MouseClick(Enum.UserInputType.MouseButton1, false)
        end
        task.wait(0.05) -- Attempt to click 1000 times per second
    end
end

CustomMatchToggle:OnChanged(function(enabled)
    pcall(function()
        if enabled then
            -- Store the original CPS value if we haven't already
            if originalClicksPerSec == nil then
                originalClicksPerSec = AutoUIController.ClicksPerSec
            end

            local success, err = pcall(function()

                AutoUIController.ClicksPerSec = 1000
                AutoFightController:StartAutoFight() 
            end)

            if not success or not AutoFightController.Active then
                customAutoClickActive = true
                if originalClicksPerSec ~= nil then
                    AutoUIController.ClicksPerSec = originalClicksPerSec
                end
                task.spawn(performCustomClicks)
            else
                customAutoClickActive = false
            end

        else
            -- Always try to stop native auto-fight first
            pcall(function()
                AutoFightController:StopAutoFight(true) -- Use colon for method call
            end)

            customAutoClickActive = false

            if originalClicksPerSec ~= nil then
                AutoUIController.ClicksPerSec = originalClicksPerSec
                originalClicksPerSec = nil
            end
        end
    end)
end)


-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Packages.Knit)

-- Player
local player = Players.LocalPlayer

-- Get all possible items from LimitedMerchant module (Pirate Merchant and Lost Merchant)
local function getAllItems()
    local LimitedMerchant = require(ReplicatedStorage.Data.LimitedMerchant)
    local allItems = {}
    local slotItemMap = {} -- Track items by slot and title to avoid duplicates
    
    local merchantNames = {"Orc Merchant"}
    
    for _, merchantName in ipairs(merchantNames) do
        local merchantData = LimitedMerchant[merchantName]
        
        if merchantData and merchantData.Items then
            for slotIndex, itemList in pairs(merchantData.Items) do
                for itemIndex, item in ipairs(itemList) do
                    local title = item.Title or "Unknown"
                    local key = merchantName .. ":" .. slotIndex .. ":" .. title
                    
                    -- Only add if this exact item in this slot hasn't been added yet
                    if not slotItemMap[key] then
                        local itemName = string.format("%s - %s (Slot %s) (%.0f %s)",
                            title,
                            merchantName,
                            slotIndex,
                            item.Price or 0,
                            typeof(item.Currency) == "string" and item.Currency or (typeof(item.Currency) == "table" and item.Currency.Item or "Unknown Currency")
                        )
                        
                        table.insert(allItems, {
                            name = itemName,
                            merchant = merchantName,
                            slot = tonumber(slotIndex),
                            index = itemIndex,
                            raw = item
                        })
                        
                        slotItemMap[key] = true
                    end
                end
            end
        end
    end

    return allItems
end

-- Get live replica data (used to check if item is currently in merchant and has stock)
local function getLiveStockData()
    local ReplicaController = require(ReplicatedStorage.ReplicaController)
    ReplicaController.RequestData()

    local startTime = tick()
    local replica
    repeat
        task.wait(0.1)
        local CustomReplicaController = Knit.GetController("CustomReplicaController")
        replica = CustomReplicaController and CustomReplicaController:GetReplica()
    until replica or tick() - startTime > 5

    local liveData = {}
    
    if replica and replica.Data and replica.Data.LimitedMerchant then
        -- Get data for both Frozen Merchant and Frontman Merchant
        local merchantNames = {"Orc Merchant"}

        for _, merchantName in ipairs(merchantNames) do
            local merchantData = replica.Data.LimitedMerchant[merchantName]
            
            if merchantData and merchantData.Items then
                for slotIndex, itemData in pairs(merchantData.Items) do
                    -- Get the actual item details from the LimitedMerchant module
                    local LimitedMerchant = require(ReplicatedStorage.Data.LimitedMerchant)
                    local currentItem = LimitedMerchant[merchantName] and 
                                      LimitedMerchant[merchantName].Items and 
                                      LimitedMerchant[merchantName].Items[slotIndex] and 
                                      LimitedMerchant[merchantName].Items[slotIndex][itemData.Index]
                    
                    -- Store more detailed information including the title for easier matching
                    liveData[merchantName .. ":" .. slotIndex] = {
                        stock = itemData.Stock,
                        index = itemData.Index,
                        title = currentItem and currentItem.Title or "Unknown",
                        fullItem = currentItem
                    }
                end
            end
        end
    end

    return liveData
end

-- UI Section
local MerchantSection = Tabs.Trial:AddSection("Merchant")

-- Get all items list and build name list + map
local allItemDataList = getAllItems()
local allItemNames = {}
local allItemDataMap = {}

for _, itemInfo in ipairs(allItemDataList) do
    table.insert(allItemNames, itemInfo.name)
    allItemDataMap[itemInfo.name] = itemInfo
end

table.sort(allItemNames)

-- Dropdown UI (before toggle)
local MerchantDropdown = MerchantSection:AddDropdown("MerchantSelect", {
    Title = "Select Item(s)",
    Description = "Choose items to auto-buy from the Merchants.",
    Values = allItemNames,
    Multi = true,
    Searchable = true,
    Default = {}
})

-- Variables to hold selected items
local selectedMerchantItems = {}

-- Toggle for Auto Buying (below dropdown)
local AutoBuyToggle = MerchantSection:AddToggle("AutoBuy", {
    Title = "Auto Buy Items",
    Default = false
})

-- Paragraph to show selected items BELOW the toggle
local SelectedItemsParagraph = MerchantSection:Paragraph("SelectedItemsDisplay", {
    Title = "Selected Items",
    Content = "None selected",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Status paragraph to show recent activity
local StatusParagraph = MerchantSection:Paragraph("StatusDisplay", {
    Title = "Status",
    Content = "Waiting to start...",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Dropdown selection changed handler
MerchantDropdown:OnChanged(function(value)
    selectedMerchantItems = value

    local selectedList = {}
    for itemName, isSelected in pairs(value) do
        if isSelected then
            table.insert(selectedList, itemName)
        end
    end

    if #selectedList > 0 then
        SelectedItemsParagraph:SetValue(table.concat(selectedList, "\n"))
    else
        SelectedItemsParagraph:SetValue("None selected")
    end
end)

-- Auto Buy Loop
AutoBuyToggle:OnChanged(function(enabled)
    if enabled then
        StatusParagraph:SetValue("Starting auto-buy loop...")
        
        task.spawn(function()
            while AutoBuyToggle.Value do
                local liveData = getLiveStockData()
                local purchasesMade = false
                
                -- Check for each selected item
                for itemName, isSelected in pairs(selectedMerchantItems) do
                    if isSelected then
                        local info = allItemDataMap[itemName]
                        
                        if info then
                            local merchantName = info.merchant
                            local slot = info.slot
                            local merchantSlotKey = merchantName .. ":" .. tostring(slot)
                            local liveInfo = liveData[merchantSlotKey]
                            
                            -- Check if this slot has an item with stock
                            if liveInfo and liveInfo.stock and liveInfo.stock > 0 then
                                -- Check if the current item in this slot is the one we want to buy
                                -- Compare titles for safer matching
                                local itemTitle = info.raw.Title
                                if itemTitle == liveInfo.title then
                                    StatusParagraph:SetValue("Found selected item: " .. itemTitle .. "\nAttempting purchase...")
                                    
                                    local success, result = pcall(function()
                                        return ReplicatedStorage.Packages.Knit.Services.LimitedMerchantService.RF.BuyItem:InvokeServer(merchantName, slot)
                                    end)
                                    
                                    if success then
                                        StatusParagraph:SetValue("Successfully purchased: " .. itemTitle)
                                        purchasesMade = true
                                    else
                                        StatusParagraph:SetValue("Failed to purchase: " .. itemTitle .. "\nError: " .. tostring(result))
                                    end
                                    
                                    -- Short delay after purchasing
                                    task.wait(0.5)
                                end
                            end
                        end
                    end
                end
                
                if not purchasesMade then
                    StatusParagraph:SetValue("Checking for selected items...\nLast check: " .. os.date("%X"))
                end
                
                -- Wait before next check cycle
                task.wait(1.5)
            end
            
            StatusParagraph:SetValue("Auto-buy stopped.")
        end)
    else
        StatusParagraph:SetValue("Auto-buy disabled.")
    end
end)

local TrialVaultSection = Tabs.Trial:AddSection("Kingdom Chest")

local KingdomChestStatus = TrialVaultSection:Paragraph("KingdomChestStatus", {
    Title = "Lost Chest Key Amount",
    Content = "Loading..."
})

local AutoOpenKingdomChestToggle = TrialVaultSection:AddToggle("AutoOpenVault", {
    Title = "Auto Open Kingdom Chest",
    Description = "Automatically opens the Kingdom Chest when you can afford it.",
    Default = false
})

local function parseAmount1(amtText1)
    local numStr = amtText1:match("x(.+)")
    if not numStr then return 0 end
    if numStr:find("k") then
        local baseNum = tonumber(numStr:match("(%d+%.?%d*)k"))
        return baseNum and (baseNum * 1000) or 0
    else
        return tonumber(numStr) or 0
    end
end

AutoOpenKingdomChestToggle:OnChanged(function(enabled)
    if enabled then
        task.spawn(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            while AutoOpenKingdomChestToggle.Value do
                local player = game.Players.LocalPlayer
                local KeyObject = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.Menus.Inventory.Display.Items.MainFrame.ScrollingFrame.KeysStorage.Objects["Lost Chest Key/1"]
                
                if KeyObject and KeyObject:FindFirstChild("ButtonDisplay") and KeyObject.ButtonDisplay:FindFirstChild("Amt") then
                    local amtText1 = KeyObject.ButtonDisplay.Amt.Text
                    local amount = parseAmount1(amtText1)
                    KingdomChestStatus:SetValue(amtText1)
                    
                    if amount >= 1 then
                        pcall(function()
                            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit.KnitClient)
                            Knit.GetService("ChestService"):Open("KingdomChest")
                        end)
                        task.wait(0.25) -- Fast check when gold is available
                    else
                        KingdomChestStatus:SetValue("No Lost Chest Keys")
                        task.wait(1) -- Slower check when no gold
                    end
                else
                    KingdomChestStatus:SetValue("No Lost Chest Keys")
                    task.wait(1) 
                end
            end
        end)
    end
end)

-- Passive Status Updater (even when toggle is off)
task.spawn(function()
    while true do
        local player = game:GetService("Players").LocalPlayer
        local KeyObject = player.PlayerGui.GameUI.Menus.Inventory.Display.Items.MainFrame.ScrollingFrame.KeysStorage.Objects:FindFirstChild("Lost Chest Key/1")
        
        if KeyObject and KeyObject:FindFirstChild("ButtonDisplay") and KeyObject.ButtonDisplay:FindFirstChild("Amt") then
            KingdomChestStatus:SetValue(KeyObject.ButtonDisplay.Amt.Text)
        else
            KingdomChestStatus:SetValue("No Lost Chest Keys")
        end
        
        task.wait(1)
    end
end)


-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Wait for Knit
local Knit = require(ReplicatedStorage.Packages.Knit)
Knit.OnStart():await()

local MiningService = Knit.GetService("MiningService")
local blocksFolder = nil -- Will be dynamically set

-- Get LayerInfo from the game module
local LayerInfoModule = require(ReplicatedStorage.Data.LayerInfo)
-- Mine reset handling variables
local isMinePaused = false
local mineResetCheckConnection
local mineResetThresholdPath1 = 5 -- Stop mining when timer is under 5s (static path)
local mineResetThresholdPath2 = 15 -- Stop mining when timer is under 15s (dynamic path)
local mineResetThresholdPath3 = 5 -- Stop mining when timer is under 30s (path along predefined points)

local function ParseTimerText(timerText)
    if not timerText or timerText == "" then return 0 end
    local minutes, seconds = timerText:match("(%d+):(%d+)")
    if minutes and seconds then return tonumber(minutes) * 60 + tonumber(seconds) end
    local m, s = timerText:match("(%d+)m%s*(%d+)s")
    if m and s then return tonumber(m) * 60 + tonumber(s) end
    local onlySeconds = timerText:match("(%d+)s")
    if onlySeconds then return tonumber(onlySeconds) end
    local numbers = {}
    for num in timerText:gmatch("(%d+)") do table.insert(numbers, tonumber(num)) end
    if #numbers >= 2 then return numbers[1] * 60 + numbers[2]
    elseif #numbers == 1 then return numbers[1] end
    return 0
end

local function ExtractBlockNames()
    local blockNames, blockSeen = {}, {}
    for _, mineLayers in pairs(LayerInfoModule) do
        for _, layerData in ipairs(mineLayers) do
            for blockName in pairs(layerData.Spawnable) do
                if not blockSeen[blockName] then table.insert(blockNames, blockName); blockSeen[blockName] = true end
            end
        end
    end
    return blockNames
end

local function ExtractBlockNamesFiltered()
    local blockNames, blockSeen = {}, {}
    local ignoredBlocks = {
        ["dirt"] = true, ["stone"] = true, ["darkstone"] = true, ["yellowstone"] = true, ["orangestone"] = true,
        ["bluestone"] = true, ["greenstone"] = true, ["redstone"] = true, ["purplestone"] = true, ["redsandstone"] = true,
        ["bluesandstone"] = true, ["greensandstone"] = true, ["yellowsandstone"] = true, ["orangesandstone"] = true,
        ["purplesandstone"] = true, ["pinksandstone"] = true, ["sand"] = true, ["sandstone"] = true,
        ["plastic"] = true, ["hardplastic"] = true, ["redplastic"] = true, ["blueplastic"] = true, ["greenplastic"] = true,
        ["yellowplastic"] = true, ["orangeplastic"] = true, ["purpleplastic"] = true, ["pinkplastic"] = true,
        ["redhardplastic"] = true, ["bluehardplastic"] = true, ["greenhardplastic"] = true, ["yellowhardplastic"] = true,
        ["orangehardplastic"] = true, ["purplehardplastic"] = true, ["pinkhardplastic"] = true
    }
    for _, mineLayers in pairs(LayerInfoModule) do
        for _, layerData in ipairs(mineLayers) do
            for blockName in pairs(layerData.Spawnable) do
                local lowerName = string.lower(blockName):gsub("%s+", "")
                if not ignoredBlocks[lowerName] and not blockSeen[blockName] then
                    table.insert(blockNames, blockName); blockSeen[blockName] = true
                end
            end
        end
    end
    return blockNames
end

local AllBlockNames = ExtractBlockNames()
local FilteredBlockNames = ExtractBlockNamesFiltered()

-- Mining variables
local selectedBlocks, pathMiningBlocks = {}, {}
local miningEnabled, targetBlockMiningEnabled, mineAlongPath = false, false, false
local blocksTransparent = false
local transparencyConnection
local targetBlock = nil

-- Master Loop Control
local masterMiningThread = nil
local currentTargetBlock = nil

local timeLeftLabel = nil
local lastPathCheck = 0
local currentPathIndex = 1
local PATH_CHECK_INTERVAL = 1

local paths = {
    function() return workspace:WaitForChild("GameObjects", 0.1):WaitForChild("Mining", 0.1):WaitForChild("Mining", 0.1):WaitForChild("MineSpawn", 0.1):WaitForChild("Attachment", 0.1):WaitForChild("BillboardGui", 0.1):WaitForChild("TimeLeft", 0.1) end,
    function() local c = workspace:WaitForChild("GameObjects", 0.1):WaitForChild("Mining", 0.1):GetChildren(); if #c >= 2 then return c[2]:WaitForChild("MineSpawn", 0.1):WaitForChild("Attachment", 0.1):WaitForChild("BillboardGui", 0.1):WaitForChild("TimeLeft", 0.1) else error() end end,
    function() local c = workspace:WaitForChild("GameObjects", 0.1):WaitForChild("Mining", 0.1):GetChildren(); if #c >= 3 then return c[3]:WaitForChild("MineSpawn", 0.1):WaitForChild("Attachment", 0.1):WaitForChild("BillboardGui", 0.1):WaitForChild("TimeLeft", 0.1) else error() end end
}

local function GetCurrentBlocksFolder()
    local s, f = pcall(function()
        local go = workspace:WaitForChild("GameObjects", 0.1):WaitForChild("Mining", 0.1)
        if currentPathIndex == 1 then return go:WaitForChild("Mining", 0.1):WaitForChild("Blocks", 0.1)
        else local c = go:GetChildren(); if currentPathIndex == 2 and #c >= 2 then return c[2]:WaitForChild("Blocks", 0.1) elseif currentPathIndex == 3 and #c >= 3 then return c[3]:WaitForChild("Blocks", 0.1) end end
    end)
    return s and f or nil
end

local function CheckAndSwitchPath()
    local now = tick()
    if now - lastPathCheck < PATH_CHECK_INTERVAL then return end
    lastPathCheck = now
    local tried, max = 0, #paths
    while tried < max do
        local s, l = pcall(paths[currentPathIndex])
        if s and l and l.Parent then timeLeftLabel = l; blocksFolder = GetCurrentBlocksFolder(); return
        else currentPathIndex = currentPathIndex % max + 1; tried = tried + 1 end
    end
    timeLeftLabel = nil
end

local function CheckMineReset()
    CheckAndSwitchPath()
    if not timeLeftLabel or not timeLeftLabel.Parent then return false end
    local secondsLeft = ParseTimerText(timeLeftLabel.Text)
    if not secondsLeft or secondsLeft <= 0 then return false end
    local threshold = (currentPathIndex == 1 and mineResetThresholdPath1) or (currentPathIndex == 2 and mineResetThresholdPath2) or (currentPathIndex == 3 and mineResetThresholdPath3) or 0
    if secondsLeft <= threshold then return true end
    if secondsLeft > threshold and isMinePaused then return false, true end
    return false
end

local function ToggleBlockTransparency(transparent)
    blocksTransparent = transparent
    if transparencyConnection then pcall(function() transparencyConnection:Disconnect() end); transparencyConnection = nil end
    local function getFolders()
        local folders, go = {}, workspace.GameObjects.Mining
        local s1, f1 = pcall(function() return go:WaitForChild("Mining", 0.1):WaitForChild("Blocks", 0.1) end)
        if s1 and f1 then table.insert(folders, f1) end
        local s2, f2 = pcall(function() local c = go:GetChildren(); if #c >= 2 then return c[2]:WaitForChild("Blocks", 0.1) end end)
        if s2 and f2 then table.insert(folders, f2) end
        local s3, f3 = pcall(function() local c = go:GetChildren(); if #c >= 3 then return c[3]:WaitForChild("Blocks", 0.1) end end)
        if s3 and f3 then table.insert(folders, f3) end
        return folders
    end
    if transparent then
        transparencyConnection = task.spawn(function()
            while blocksTransparent do
                for _, folder in ipairs(getFolders()) do if folder and folder:IsDescendantOf(workspace) then for _, block in ipairs(folder:GetChildren()) do if block and block:FindFirstChild("Primary") then block.Primary.Transparency = 0.7 end end end end
                task.wait(3)
            end
        end)
    else
        for _, folder in ipairs(getFolders()) do if folder and folder:IsDescendantOf(workspace) then for _, block in ipairs(folder:GetChildren()) do if block and block:FindFirstChild("Primary") then block.Primary.Transparency = 0 end end end end
    end
end

local function BlockExists(block) return block and block.Parent and blocksFolder and block.Parent == blocksFolder end
local function GetHighestDepthBlock()
    if not blocksFolder or not blocksFolder:IsDescendantOf(workspace) then blocksFolder = GetCurrentBlocksFolder(); if not blocksFolder then return nil end end
    local highestBlock, highestDepth = nil, -1
    for _, block in ipairs(blocksFolder:GetChildren()) do local depth = block:GetAttribute("Depth") or 0; if depth > highestDepth then highestDepth = depth; highestBlock = block end end
    return highestBlock
end

-- ✅ Re-added the helper function to handle the "same depth" scenario.
local function getRandomBlockIfDepthsAreSame()
    if not blocksFolder or not blocksFolder:IsDescendantOf(workspace) then return nil end
    local blocks = blocksFolder:GetChildren()
    if #blocks <= 1 then return nil end -- Not enough blocks to compare

    local firstDepth = blocks[1]:GetAttribute("Depth")
    if firstDepth == nil then return nil end -- Cannot compare if the first block is invalid

    for i = 2, #blocks do
        if (blocks[i]:GetAttribute("Depth") or -1) ~= firstDepth then
            return nil -- Depths are different, so do nothing.
        end
    end

    -- If we reach here, all depths are the same. Return a random block.
    return blocks[math.random(1, #blocks)]
end

-- This function is the single source for deciding what to mine.
-- It now includes the random block logic as its highest priority.
local function updateMiningTarget()
    if not blocksFolder or not blocksFolder:IsDescendantOf(workspace) then blocksFolder = GetCurrentBlocksFolder(); if not blocksFolder then currentTargetBlock = nil; return end end
    
    -- ✅ Priority 0: If all blocks are at the same depth, pick one randomly to break ties.
    local randomBlock = getRandomBlockIfDepthsAreSame()
    if randomBlock then
        currentTargetBlock = randomBlock
        return -- We found our target, exit early
    end

    -- Priority 1: Mine Along the Way
    if mineAlongPath and #pathMiningBlocks > 0 then
        for _, block in ipairs(blocksFolder:GetChildren()) do
            for _, targetName in ipairs(pathMiningBlocks) do
                if string.find(string.lower(block.Name), string.lower(targetName)) then
                    currentTargetBlock = block; return
                end
            end
        end
    end

    -- Priority 2: Auto Mine to Target
    if targetBlockMiningEnabled and targetBlock then
        -- Try to find the target block
        for _, block in ipairs(blocksFolder:GetChildren()) do
            if string.find(string.lower(block.Name), string.lower(targetBlock)) then
                currentTargetBlock = block; return
            end
        end
        -- If not found, dig to the deepest point
        currentTargetBlock = GetHighestDepthBlock(); return
    end

    -- Priority 3: General Auto Mining
    if miningEnabled then
        -- Find block from selected dropdown
        if #selectedBlocks > 0 then
            for _, block in ipairs(blocksFolder:GetChildren()) do
                for _, oreName in ipairs(selectedBlocks) do
                    if string.find(string.lower(block.Name), string.lower(oreName)) then
                        currentTargetBlock = block; return
                    end
                end
            end
        end
        -- If none selected or found, dig to deepest
        currentTargetBlock = GetHighestDepthBlock(); return
    end

    -- If no toggles are active, clear the target
    currentTargetBlock = nil
end

-- The single, optimized master loop
local function MasterMiningLoop()
    local lastTargetUpdateTime = 0
    while miningEnabled or targetBlockMiningEnabled or mineAlongPath do
        pcall(function()
            if not isMinePaused then
                -- Target Acquisition (Slow Task - every 5 seconds)
                if tick() - lastTargetUpdateTime > 5 then
                    updateMiningTarget()
                    lastTargetUpdateTime = tick()
                end

                -- Mining Action (Fast Task - every 0.1 seconds)
                if currentTargetBlock and BlockExists(currentTargetBlock) then
                    MiningService:MineBlock(currentTargetBlock):andThen(function() end)
                else
                    -- Target is gone, force a new target search on the next loop iteration
                    lastTargetUpdateTime = 0 
                end
            end
        end)
        task.wait(0.1) -- ✅ Kept your faster 0.1 second interval
    end
    masterMiningThread = nil -- Loop finished, clear the thread variable
end

-- Function to start/stop the master loop
local function ManageMasterLoop()
    if (miningEnabled or targetBlockMiningEnabled or mineAlongPath) and not masterMiningThread then
        masterMiningThread = task.spawn(MasterMiningLoop)
    end
end

local function StartMineResetMonitoring()
    if mineResetCheckConnection then mineResetCheckConnection:Disconnect() end
    mineResetCheckConnection = RunService.Heartbeat:Connect(function()
        local shouldPause, hasReset = CheckMineReset()
        if shouldPause and not isMinePaused then isMinePaused = true
        elseif not shouldPause and isMinePaused then isMinePaused = false end
        if hasReset then
            blocksFolder = GetCurrentBlocksFolder()
            currentTargetBlock = nil -- Force retarget after reset
            if blocksTransparent then ToggleBlockTransparency(false); ToggleBlockTransparency(true) end
        end
    end)
end

blocksFolder = GetCurrentBlocksFolder()

local miningSection = Tabs.Mining:AddSection("Mining Controls")
local miningToggle = Tabs.Mining:AddToggle("MiningToggle", { Title = "Auto Mining", Default = false })
local blockDropdown = Tabs.Mining:AddDropdown("BlockSelection", { Title = "Select Blocks to Mine", Values = AllBlockNames, Multi = true, Default = {}, Searchable = true })
blockDropdown:OnChanged(function(v) selectedBlocks = {}; for b, s in pairs(v) do if s then table.insert(selectedBlocks, b) end end end)

local targetSection = Tabs.Mining:AddSection("Target Block")
local targetBlockDropdown = Tabs.Mining:AddDropdown("TargetBlockSelection", { Title = "Target Ore", Values = AllBlockNames, Multi = false, Default = "", Searchable = true })
targetBlockDropdown:OnChanged(function(v) targetBlock = v end)
local pathMiningDropdown = Tabs.Mining:AddDropdown("PathMiningBlocks", { Title = "Mine Blocks Along the Way", Values = FilteredBlockNames, Multi = true, Default = {}, Searchable = true })
pathMiningDropdown:OnChanged(function(v) pathMiningBlocks = {}; for b, s in pairs(v) do if s then table.insert(pathMiningBlocks, b) end end end)

local pathMiningToggle = Tabs.Mining:AddToggle("PathMining", { Title = "Mine Along the Way", Default = false, Description = "Mine selected valuable blocks while digging around" })
pathMiningToggle:OnChanged(function(v) mineAlongPath = v; ManageMasterLoop() end)

local targetMiningToggle = Tabs.Mining:AddToggle("TargetMining", { Title = "Auto Mine to Target", Default = false, Description = "Automatically mine to reach target ore's depth" })
targetMiningToggle:OnChanged(function(v)
    targetBlockMiningEnabled = v
    if v then if miningEnabled then miningToggle:SetValue(false) end end
    ManageMasterLoop()
end)

miningToggle:OnChanged(function(v)
    miningEnabled = v
    if v then if targetBlockMiningEnabled then targetMiningToggle:SetValue(false) end end
    ManageMasterLoop()
end)

local transparencySection = Tabs.Mining:AddSection("Transparency")
local transparencyToggle = Tabs.Mining:AddToggle("BlockTransparency", { Title = "Block Transparency", Default = false })
transparencyToggle:OnChanged(function(v) ToggleBlockTransparency(v) end)

local resetSection = Tabs.Mining:AddSection("Mine Reset Status")
local resetStatusLabel = resetSection:AddParagraph("ResetStatus", { Title = "Mine Reset Timer", Content = "Checking..." })
spawn(function()
    while true do
        local s, t = pcall(function()
            if timeLeftLabel and timeLeftLabel:IsDescendantOf(workspace) then
                local th = (currentPathIndex == 1 and mineResetThresholdPath1) or (currentPathIndex == 2 and mineResetThresholdPath2) or (currentPathIndex == 3 and mineResetThresholdPath3) or 0
                local sl = ParseTimerText(timeLeftLabel.Text) or 0
                return timeLeftLabel.Text .. " (Threshold: " .. th .. "s, Path: " .. currentPathIndex .. ", Seconds: " .. sl .. ")"
            end
            return "Timer not found"
        end)
        resetStatusLabel:SetContent("Mine Reset: " .. (s and t or "Error"))
        wait(1)
    end
end)

StartMineResetMonitoring()
-- Add Smelt Ores Section
local SmeltSection = Tabs.Mining:AddSection("Smelt Ores")

-- Add Fuel toggle
local addFuelToggle = SmeltSection:AddToggle("AddFuel", {
    Title = "Add Fuel (Coal)",
    Description = "Automatically adds coal as fuel.",
    Default = false
})

addFuelToggle:OnChanged(function()
    if addFuelToggle.Value then
        spawn(function()
            while addFuelToggle.Value do
                pcall(function()
                    local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit.KnitClient)
                    Knit.GetService("OreSmeltingService"):AddAllOres("Coal Ore", 1)
                end)
                wait(5) -- Every 5 seconds
            end
        end)
    end
end)

-- Auto Claim toggle
local autoClaimSmeltToggle = SmeltSection:AddToggle("AutoClaimSmelt", {
    Title = "Auto Claim",
    Description = "Automatically claims the smelted ores.",
    Default = false
})

autoClaimSmeltToggle:OnChanged(function()
    if autoClaimSmeltToggle.Value then
        spawn(function()
            while autoClaimSmeltToggle.Value do
                pcall(function()
                    local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit.KnitClient)
                    Knit.GetService("OreSmeltingService"):ClaimSmelting()
                end)
                wait(1) -- Every second
            end
        end)
    end
end)

-- Function to get available ores from inventory
local function GetAvailableOres()
    local availableOres = {}
    
    pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Knit = require(ReplicatedStorage.Packages.Knit)
        local CustomReplicaController = Knit.GetController("CustomReplicaController")
        local ItemInfo = require(ReplicatedStorage.Data.Item.ItemInfo)
        
        local playerData = CustomReplicaController:GetReplica()
        local inventory = playerData.Data.Items.ItemInventory.Misc
        
        for itemName, itemData in pairs(inventory) do
            local itemInfo = ItemInfo[itemName]
            if itemInfo and itemInfo.Ore then
                local tier1Amount = itemData["1"]
                if tier1Amount and tier1Amount > 0 then
                    table.insert(availableOres, itemName)
                end
            end
        end
    end)
    
    return availableOres
end

-- Function to check if main smelting slot is empty
local function IsMainSlotEmpty()
    local isEmpty = true
    
    pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Knit = require(ReplicatedStorage.Packages.Knit)
        local CustomReplicaController = Knit.GetController("CustomReplicaController")
        
        local playerData = CustomReplicaController:GetReplica()
        local smeltingData = playerData.Data.SmeltingData
        
        isEmpty = not smeltingData.SmeltingOre.Item or smeltingData.SmeltingOre.Item == ""
    end)
    
    return isEmpty
end

-- Smelt All Ores toggle
local smeltAllOresToggle = SmeltSection:AddToggle("SmeltAllOres", {
    Title = "Smelt All Ores",
    Description = "Automatically adds ores to smelt.",
    Default = false
})

smeltAllOresToggle:OnChanged(function()
    if smeltAllOresToggle.Value then
        spawn(function()
            while smeltAllOresToggle.Value do
                pcall(function()
                    -- Check if main slot is empty
                    if IsMainSlotEmpty() then
                        local availableOres = GetAvailableOres()
                        
                        if #availableOres > 0 then
                            -- Pick a random ore
                            local randomOre = availableOres[math.random(1, #availableOres)]
                            
                            -- Add the random ore to smelting
                            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit.KnitClient)
                            Knit.GetService("OreSmeltingService"):AddAllOres(randomOre, 1)
                            
                            
                            -- Wait a bit for the ore to be added
                            wait(2)
                        end
                    end
                end)
                
                wait(3) -- Check every 3 seconds
            end
        end)
    end
end)

local Inventory = Tabs.Mining:AddSection("Auto Sell")

-- Add cooldown input with default value of 10
local sellCooldownInput = Inventory:AddInput("SellCooldown", {
    Title = "Sell Cooldown (seconds)",
    Default = "10",
    Placeholder = "Enter cooldown in seconds",
    Numeric = true, -- Only allow numbers
    Finished = false, -- Call callback when user is done typing
    Callback = function(Value) end
})

-- Add Auto Sell toggle
local autoSellToggle = Inventory:AddToggle("AutoSell", {
    Title = "Auto Sell",
    Description = "Automatically sells your mining inventory on the specified cooldown",
    Default = false
})

-- Auto Sell toggle handler
autoSellToggle:OnChanged(function()
    if autoSellToggle.Value then
        spawn(function()
            while autoSellToggle.Value do
                -- Sell inventory
                pcall(function()
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.OreMarketService.RF.SellInventory:InvokeServer()
                end)
                
                -- Wait for cooldown (with a safety check for non-numeric input)
                local cooldown = tonumber(sellCooldownInput.Value) or 10
                if cooldown < 1 then cooldown = 1 end -- Minimum 1 second cooldown
                wait(cooldown)
            end
        end)
    end
end)

-- Add Pickaxe Purchase Section
local PickaxeSection = Tabs.Mining:AddSection("Pickaxe Purchase")

-- Function to format numbers
local function formatNumber(num)
    if not num or type(num) ~= "number" then return "0" end
    
    if num >= 1e15 then
        return string.format("%.2fQ", num / 1e15)
    elseif num >= 1e12 then
        return string.format("%.2fT", num / 1e12)
    elseif num >= 1e9 then
        return string.format("%.2fB", num / 1e9)
    elseif num >= 1e6 then
        return string.format("%.2fM", num / 1e6)
    elseif num >= 1e3 then
        return string.format("%.2fK", num / 1e3)
    else
        return tostring(num)
    end
end

-- Initialize pickaxe data
local pickaxeData = {
    allPickaxes = {},
    missingPickaxes = {},
    ownedPickaxes = {},
    pickaxeNames = {},
    nextPickaxe = nil,
    selectedPickaxe = nil,
    bestOwned = nil,
    currentlyEquipped = nil,
    playerCoins = 0
}

-- Function to get player's mining coins
local function GetPlayerMiningCoins()
    local localPlayer = game:GetService("Players").LocalPlayer
    local miningCoins = 0
    
    -- Try to get the MiningCoins attribute
    pcall(function()
        miningCoins = localPlayer:GetAttribute("MiningCoins") or 0
    end)
    
    return miningCoins
end

-- Function to get currently equipped pickaxe using MiningController
local function GetEquippedPickaxe()
    local equippedName = ""
    
    pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local MiningController = require(ReplicatedStorage.Controllers.MiningController)
        
        if MiningController and MiningController.CurrentPickaxe then
            equippedName = MiningController.CurrentPickaxe.Name
        end
    end)
    
    -- Fallback to old method if MiningController method fails
    if equippedName == "" then
        pcall(function()
            local playerReplica = game:GetService("ReplicatedStorage").Packages.Knit.GetController("CustomReplicaController"):GetReplica()
            if playerReplica and playerReplica.Data then
                equippedName = playerReplica.Data.EquippedPickaxe or ""
            end
        end)
    end
    
    return equippedName
end

-- Function to get pickaxe data with improved error handling
local function LoadPickaxeData()
    -- Clear existing data
    pickaxeData.allPickaxes = {}
    pickaxeData.missingPickaxes = {}
    pickaxeData.ownedPickaxes = {}
    pickaxeData.pickaxeNames = {}
    
    -- Get current coins
    pickaxeData.playerCoins = GetPlayerMiningCoins()
    
    -- Wrap everything in pcall to catch any errors
    local success, errorMsg = pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        
        -- Load necessary modules with error handling
        local ItemController, ItemInfo, pickaxesFolder
        
        -- Try to load ItemController
        pcall(function()
            -- Try different paths for ItemController
            ItemController = require(ReplicatedStorage.Controllers.Item.ItemController) or
                             require(ReplicatedStorage.Controllers.ItemController)
        end)
        
        -- Try to load ItemInfo
        pcall(function()
            ItemInfo = require(ReplicatedStorage.Data.Item.ItemInfo)
        end)
        
        -- Try to get pickaxes folder
        pcall(function()
            pickaxesFolder = ReplicatedStorage:WaitForChild("Tools"):WaitForChild("Pickaxes")
        end)
        
        -- Check if we have all required components
        if not ItemController or not ItemInfo or not pickaxesFolder then
            warn("Missing required components for pickaxe data loading")
            return false
        end
        
        -- Get currently equipped pickaxe using the improved function
        local equippedPickaxe = GetEquippedPickaxe()
        
        -- Process each pickaxe
        for _, pickaxeObj in pairs(pickaxesFolder:GetChildren()) do
            local pickaxeName = pickaxeObj.Name
            
            if ItemInfo[pickaxeName] then
                local pickaxeItemData = ItemInfo[pickaxeName]
                local tierInfo = pickaxeItemData.Tiers and pickaxeItemData.Tiers[1]
                local rarity = tierInfo and tierInfo.Rarity or "Unknown"
                local price = pickaxeItemData.Price or (tierInfo and tierInfo.Price or 0)
                
                -- Check if player owns this pickaxe
                local isOwned = false
                pcall(function()
                    isOwned = ItemController:GetItemAmount({
                        Item = pickaxeName,
                        Tier = 1
                    }) > 0
                end)
                
                -- Check if this is the equipped pickaxe
                local isEquipped = (pickaxeName == equippedPickaxe)
                
                -- Create pickaxe info table with formatted price
                local formattedPriceStr = formatNumber(price)
                
                local pickaxeInfo = {
                    name = pickaxeName,
                    price = price,
                    formattedPrice = formattedPriceStr,
                    rarity = rarity,
                    owned = isOwned,
                    equipped = isEquipped,
                    canAfford = (pickaxeData.playerCoins >= price)
                }
                
                -- Add to all pickaxes list and name list
                table.insert(pickaxeData.allPickaxes, pickaxeInfo)
                table.insert(pickaxeData.pickaxeNames, pickaxeName)
                
                -- Add to appropriate ownership list
                if isOwned then
                    table.insert(pickaxeData.ownedPickaxes, pickaxeInfo)
                    
                    -- Track equipped pickaxe
                    if isEquipped then
                        pickaxeData.currentlyEquipped = pickaxeInfo
                    end
                else
                    table.insert(pickaxeData.missingPickaxes, pickaxeInfo)
                end
            end
        end
        
        -- Sort pickaxes by price
        table.sort(pickaxeData.allPickaxes, function(a, b) return a.price < b.price end)
        table.sort(pickaxeData.ownedPickaxes, function(a, b) return a.price < b.price end)
        table.sort(pickaxeData.missingPickaxes, function(a, b) return a.price < b.price end)
        
        -- Find the best owned pickaxe (most expensive)
        if #pickaxeData.ownedPickaxes > 0 then
            pickaxeData.bestOwned = pickaxeData.ownedPickaxes[#pickaxeData.ownedPickaxes]
            local bestOwnedIndex = 0
            
            -- Find the index of the best owned pickaxe in the allPickaxes array
            for i, pickaxe in ipairs(pickaxeData.allPickaxes) do
                if pickaxe.name == pickaxeData.bestOwned.name then
                    bestOwnedIndex = i
                    break
                end
            end
            
            -- Set the next pickaxe to buy (the one after your best owned)
            if bestOwnedIndex > 0 and bestOwnedIndex < #pickaxeData.allPickaxes then
                -- Get the next pickaxe after your best owned one
                pickaxeData.nextPickaxe = pickaxeData.allPickaxes[bestOwnedIndex + 1]
            elseif bestOwnedIndex == #pickaxeData.allPickaxes then
                -- If you own the best pickaxe, there's no next one
                pickaxeData.nextPickaxe = nil
            end
        elseif #pickaxeData.allPickaxes > 0 then
            -- If you own no pickaxes, get the cheapest one
            pickaxeData.nextPickaxe = pickaxeData.allPickaxes[1]
        end
    end)
    
    if not success then
        warn("Error loading pickaxe data: " .. tostring(errorMsg))
        -- Add a default next pickaxe to prevent nil errors
        pickaxeData.nextPickaxe = {
            name = "Error loading pickaxes",
            price = 0,
            formattedPrice = "Error",
            rarity = "Unknown",
            owned = false,
            equipped = false,
            canAfford = false
        }
    end
    
    return success
end

-- Add Pickaxe dropdown
local pickaxeDropdown = PickaxeSection:AddDropdown("PickaxeSelect", {
    Title = "Select Pickaxe",
    Values = {"Loading..."},
    Multi = false,
    Default = "Wooden Pickaxe",
    Searchable = true
})

-- Add Buy button
local buyPickaxeButton = PickaxeSection:AddButton({
    Title = "Buy Selected Pickaxe",
    Description = "Purchase the pickaxe selected above",
    Callback = function()
        if pickaxeData.selectedPickaxe then
            -- Buy the selected pickaxe using the direct Remote Function
            pcall(function()
                local args = {
                    [1] = pickaxeData.selectedPickaxe
                }
                
                game:GetService("ReplicatedStorage").Packages.Knit.Services.PickaxeMerchantService.RF.BuyPickaxe:InvokeServer(unpack(args))
                
                -- Wait a moment before reloading data to allow the purchase to process
                wait(1)
                
                -- Reload pickaxe data after purchase
                LoadPickaxeData()
                
                -- Update next pickaxe status
                UpdateNextPickaxeStatus()
                
                -- Update dropdown values
                UpdatePickaxeDropdown()
            end)
        end
    end
})

-- Add auto-buy next pickaxe toggle
local nextPickaxeStatus = PickaxeSection:AddParagraph("NextPickaxeStatus", {
    Title = "Next Pickaxe",
    Content = "Loading pickaxe data..."
})

-- Function to update next pickaxe status
function UpdateNextPickaxeStatus()
    if not pickaxeData.nextPickaxe then
        nextPickaxeStatus:SetContent("You own all pickaxes!")
        return
    end
    
    local coins = GetPlayerMiningCoins()
    local nextPickaxeName = pickaxeData.nextPickaxe.name
    local nextPickaxePrice = pickaxeData.nextPickaxe.price
    local formattedCoins = formatNumber(coins)
    local formattedPrice = formatNumber(nextPickaxePrice)
    
    local statusContent = "Next: " .. nextPickaxeName .. " (" .. formattedPrice .. ")\n"
    statusContent = statusContent .. "Your coins: " .. formattedCoins
    
    if coins < nextPickaxePrice then
        local needed = nextPickaxePrice - coins
        statusContent = statusContent .. "\nNeed " .. formatNumber(needed) .. " more coins"
    else
        statusContent = statusContent .. "\nYou can afford this pickaxe!"
    end
    
    nextPickaxeStatus:SetContent(statusContent)
end

-- Auto buy toggle
local autoBuyNextToggle = PickaxeSection:AddToggle("AutoBuyNext", {
    Title = "Auto Buy Next Pickaxe",
    Description = "Automatically buys the next progressive pickaxe when affordable",
    Default = false
})

-- Function to update dropdown values
function UpdatePickaxeDropdown()
    pcall(function()
        -- Load names of all pickaxes
        local pickaxeNames = {}
        for _, pickaxe in ipairs(pickaxeData.allPickaxes) do
            table.insert(pickaxeNames, pickaxe.name)
        end
        
        -- If no pickaxes loaded, add a placeholder
        if #pickaxeNames == 0 then
            table.insert(pickaxeNames, "No pickaxes found")
        end
        
        -- Update dropdown values
        pickaxeDropdown:SetValues(pickaxeNames)
    end)
end

-- Add Auto Equip Section
local AutoEquipSection = Tabs.Mining:AddSection("Auto Equip")

-- Auto equip status
local equipStatus = AutoEquipSection:AddParagraph("EquipStatus", {
    Title = "Pickaxe Status",
    Content = "Loading pickaxe data..."
})

-- Auto equip toggle
local autoEquipToggle = AutoEquipSection:AddToggle("AutoEquipBest", {
    Title = "Auto Equip Best Pickaxe",
    Description = "Automatically equips your best pickaxe if it isn't equipped",
    Default = false
})

-- Function to update equip status
function UpdateEquipStatus()
    if not pickaxeData.bestOwned then
        equipStatus:SetContent("No pickaxes owned")
        return
    end
    
    local statusContent = "Best: " .. pickaxeData.bestOwned.name
    
    if pickaxeData.currentlyEquipped then
        statusContent = statusContent .. "\nEquipped: " .. pickaxeData.currentlyEquipped.name
        
        if pickaxeData.bestOwned.name == pickaxeData.currentlyEquipped.name then
            statusContent = statusContent .. "\nStatus: Best pickaxe equipped"
        else
            statusContent = statusContent .. "\nStatus: Not using best pickaxe"
        end
    else
        statusContent = statusContent .. "\nNo pickaxe equipped"
    end
    
    equipStatus:SetContent(statusContent)
end

-- Function to equip best pickaxe
function EquipBestPickaxe()
    if not pickaxeData.bestOwned then return end
    
    -- Check if best pickaxe is already equipped
    if pickaxeData.currentlyEquipped and pickaxeData.currentlyEquipped.name == pickaxeData.bestOwned.name then
        return
    end
    
    -- Equip best pickaxe
    pcall(function()
        local args = {
            [1] = pickaxeData.bestOwned.name
        }
        
        game:GetService("ReplicatedStorage").Packages.Knit.Services.PickaxeMerchantService.RF.EquipPickaxe:InvokeServer(unpack(args))
        
        -- Wait a moment before reloading data
        wait(1)
        
        -- Reload pickaxe data
        LoadPickaxeData()
        
        -- Update equip status
        UpdateEquipStatus()
    end)
end

-- Load pickaxe data with retry
spawn(function()
    local success = false
    local attempts = 0
    
    while not success and attempts < 5 do
        attempts = attempts + 1
        success = LoadPickaxeData()
        
        if not success then
            nextPickaxeStatus:SetContent("Loading attempt " .. attempts .. "/5...")
            wait(2) -- Wait before retrying
        end
    end
    
    -- Update UI based on result
    if success then
        UpdateNextPickaxeStatus()
        UpdateEquipStatus()
        UpdatePickaxeDropdown()
    else
        nextPickaxeStatus:SetContent("Failed to load pickaxe data. Try rejoining.")
        equipStatus:SetContent("Failed to load pickaxe data.")
    end
    
    -- Start status update loop
    spawn(function()
        while wait(5) do
            LoadPickaxeData()
            UpdateNextPickaxeStatus()
            UpdateEquipStatus()
        end
    end)
end)

-- Handle dropdown selection
pickaxeDropdown:OnChanged(function(value)
    if value ~= "Loading..." and value ~= "No pickaxes found" then
        pickaxeData.selectedPickaxe = value
    end
end)

-- Auto buy next pickaxe toggle handler
autoBuyNextToggle:OnChanged(function()
    if autoBuyNextToggle.Value then
        spawn(function()
            while autoBuyNextToggle.Value do
                -- Reload pickaxe data to get the latest info
                local success = LoadPickaxeData()
                
                if success and pickaxeData.nextPickaxe then
                    -- Check if player can afford the next pickaxe
                    local playerCoins = GetPlayerMiningCoins()
                    
                    if playerCoins >= pickaxeData.nextPickaxe.price then
                        -- Update status to show we are buying
                        nextPickaxeStatus:SetContent("Buying: " .. pickaxeData.nextPickaxe.name)
                        
                        -- Attempt to buy the next pickaxe
                        pcall(function()
                            -- ✅ CORRECTED: Use Knit service to buy the next best pickaxe
                            local PickaxeService = Knit.GetService("PickaxeMerchantService")
                            PickaxeService:BuyPickaxe(pickaxeData.nextPickaxe.name)
                            
                            -- Wait a moment for the purchase to process
                            wait(1)
                            
                            -- Reload all data and update UI after purchase
                            LoadPickaxeData()
                            UpdateNextPickaxeStatus()
                            UpdateEquipStatus()
                            UpdatePickaxeDropdown()
                        end)
                    else
                        -- Not enough coins, update status and wait
                        UpdateNextPickaxeStatus()
                    end
                else
                    -- Handle cases where data fails to load or all pickaxes are owned
                    if not success then
                        nextPickaxeStatus:SetContent("Error loading pickaxe data")
                    else
                        nextPickaxeStatus:SetContent("You own all pickaxes!")
                        autoBuyNextToggle:SetValue(false) -- Turn off toggle
                        break
                    end
                end
                
                wait(5) -- Wait 5 seconds before checking again
            end
        end)
    end
end)

-- Auto equip toggle handler
autoEquipToggle:OnChanged(function()
    if autoEquipToggle.Value then
        spawn(function()
            while autoEquipToggle.Value do
                -- Reload pickaxe data to get the latest
                local success = LoadPickaxeData()
                
                if success then
                    -- Check if best pickaxe is already equipped
                    if pickaxeData.bestOwned and pickaxeData.currentlyEquipped then
                        if pickaxeData.bestOwned.name ~= pickaxeData.currentlyEquipped.name then
                            EquipBestPickaxe()
                        end
                    elseif pickaxeData.bestOwned then
                        -- If no pickaxe equipped but we have one
                        EquipBestPickaxe()
                    end
                    
                    -- Update equip status
                    UpdateEquipStatus()
                end
                
                wait(5) -- Check every 5 seconds
            end
        end)
    end
end)


local MiningVaultSection = Tabs.Mining:AddSection("Mining Vault")

local MiningGoldStatus = MiningVaultSection:Paragraph("MiningGoldStatus", {
    Title = "Mining Gold Amount",
    Content = "Loading..."
})

local AutoOpenVaultToggle = MiningVaultSection:AddToggle("AutoOpenVault", {
    Title = "Auto Open Mining Vault",
    Description = "Automatically opens Mining Vault when you have Mining Gold.",
    Default = false
})

local function parseAmount(amtText)
    local numStr = amtText:match("x(.+)")
    if not numStr then return 0 end
    if numStr:find("k") then
        local baseNum = tonumber(numStr:match("(%d+%.?%d*)k"))
        return baseNum and (baseNum * 1000) or 0
    else
        return tonumber(numStr) or 0
    end
end

-- Auto Open Mining Vault Loop
AutoOpenVaultToggle:OnChanged(function(enabled)
    if enabled then
        task.spawn(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            while AutoOpenVaultToggle.Value do
                local player = game.Players.LocalPlayer
                local goldObject = player.PlayerGui.GameUI.Menus.Inventory.Display.Items.MainFrame.ScrollingFrame.KeysStorage.Objects:FindFirstChild("Mining Gold/1")
                
                if goldObject and goldObject:FindFirstChild("ButtonDisplay") and goldObject.ButtonDisplay:FindFirstChild("Amt") then
                    local amtText = goldObject.ButtonDisplay.Amt.Text
                    local amount = parseAmount(amtText)
                    MiningGoldStatus:SetValue(amtText)
                    
                    if amount >= 1 then
                        pcall(function()
                            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit.KnitClient)
                            Knit.GetService("ChestService"):Open("MiningVault")
                        end)
                        task.wait(0.25) -- Fast check when gold is available
                    else
                        MiningGoldStatus:SetValue("No Gold")
                        task.wait(1) -- Slower check when no gold
                    end
                else
                    MiningGoldStatus:SetValue("No Gold")
                    task.wait(1) -- Slower check when GUI element doesn't exist
                end
            end
        end)
    end
end)

-- Passive Status Updater (even when toggle is off)
task.spawn(function()
    while true do
        local player = game:GetService("Players").LocalPlayer
        local goldObject = player.PlayerGui.GameUI.Menus.Inventory.Display.Items.MainFrame.ScrollingFrame.KeysStorage.Objects:FindFirstChild("Mining Gold/1")
        
        if goldObject and goldObject:FindFirstChild("ButtonDisplay") and goldObject.ButtonDisplay:FindFirstChild("Amt") then
            MiningGoldStatus:SetValue(goldObject.ButtonDisplay.Amt.Text)
        else
            MiningGoldStatus:SetValue("No Gold")
        end
        
        task.wait(1)
    end
end)

-- Hand the library over to our managers
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes{}

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab("Settings")

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()


