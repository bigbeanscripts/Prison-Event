-- Function to get all valid egg names in alphabetical order, excluding "Egg Rewind"
local function getEggNames()
    local eggNames = {}
    local zones = workspace:FindFirstChild("Zones")

    if zones then
        for _, zone in pairs(zones:GetChildren()) do
            if zone:IsA("Folder") and not zone.Name:match("%d") then -- Ignore zones with numbers
                local interactables = zone:FindFirstChild("Interactables")
                if interactables then
                    local eggs = interactables:FindFirstChild("Eggs")
                    if eggs then
                        for _, egg in pairs(eggs:GetChildren()) do
                            if egg.Name ~= "Rewind" then
                                table.insert(eggNames, egg.Name)
                            end
                        end
                    end
                end
            end
        end
    end

    table.sort(eggNames) -- Sort alphabetically
    return eggNames
end


local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()


local Window = Library:Window{
    Title = "Sumemer Event",
    SubTitle = "By Duckie",
    TabWidth = 160,
    Size =  UDim2.fromOffset(580, 460),
    Resize = false, 
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}


local Tabs = {
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
    AutoFight = Window:AddTab({ Title = "Auto Train/Fight", Icon = "crown" }),
    Eggs = Window:AddTab({ Title = "Eggs", Icon = "egg" }),
    Wheel = Window:AddTab({ Title = "Wheel", Icon = "ferris-wheel" }),
    Merchant = Window:AddTab({ Title = "Merchant", Icon = "phosphor-shopping-cart-fill" }),
    Fish = Window:AddTab({ Title = "Fish", Icon = "phosphor-fish" }),
    Quest = Window:AddTab({ Title = "Quest", Icon = "phosphor-flag" })
}





local function GetCurrentZone()
    local player = game.Players.LocalPlayer

    if player:GetAttribute("ZoneSummerIsland") then
        return "SummerIsland"
    end

    -- Look through workspace as fallback
    local duckZone = workspace.Zones:FindFirstChild("SummerIsland") or workspace.Zones:FindFirstChild("SummerIsland")
    if duckZone then
        return duckZone.Name
    end

    return nil
end

local function GetBestDuckBag()
    local player = game.Players.LocalPlayer
    local currentZone = GetCurrentZone()
    
    if not currentZone then
        return "Tier1"
    end
    
    local knuckleStrength = player:GetAttribute("TotalSummerKnucklesV2") or 0
    local punchBagData = require(game:GetService("ReplicatedStorage").Data.PunchBags)
    
    if player:GetAttribute("VIP") == true then
        return "VIP"
    end
    
    local bestTier = "Tier1"  
    local highestRequired = 0
    
    if punchBagData and punchBagData[currentZone] then
        for tier, data in pairs(punchBagData[currentZone]) do
            if data.StrengthRequired and 
               knuckleStrength >= data.StrengthRequired and 
               data.StrengthRequired > highestRequired then
                bestTier = tier
                highestRequired = data.StrengthRequired
            end
        end
    end
    
    return bestTier
end

local function GetBestDuckEquipment(equipmentType)
    local player = game.Players.LocalPlayer
    local currentZone = GetCurrentZone()
    
    if not currentZone then
        return "SummerIsland1" -- Default equipment
    end
    
    -- Determine which attribute and data to use based on equipment type
    local attributeName, dataModule, defaultEquipment
    
    
    if equipmentType == "Dumbells" then
        attributeName = "TotalSummerBicepV2"
        dataModule = "Dumbells"
        defaultEquipment = "SummerIsland1"
    elseif equipmentType == "Grips" then
        attributeName = "TotalSummerGripV2"
        dataModule = "Grips"
        defaultEquipment = "SumerIsland1"
    elseif equipmentType == "Barbells" then 
        attributeName = "TotalSummerBicepV2"
        dataModule = "Barbells"
        defaultEquipment = "SummerIsland1"
    else
        -- Default to Dumbells if unknown type
        attributeName = "TotalSummerBicepV2"
        dataModule = "Dumbells"
        defaultEquipment = "SummerIsland1"
    end
    
    
    local statValue = player:GetAttribute(attributeName) or 0
    
    local equipmentData
    pcall(function()
        equipmentData = require(game:GetService("ReplicatedStorage").Data[dataModule])
    end)
    
    if not equipmentData then
        return defaultEquipment
    end
    
    local bestEquipment = defaultEquipment
    local highestRequired = 0
    
    if equipmentData and equipmentData[currentZone] then
        for name, data in pairs(equipmentData[currentZone]) do
            if data.StrengthRequired and 
               statValue >= data.StrengthRequired and 
               data.StrengthRequired > highestRequired then
                bestEquipment = name
                highestRequired = data.StrengthRequired
            end
        end
    end

    return bestEquipment
end


-- Add Training Section
local TrainSection = Tabs.AutoFight:AddSection("Duck Auto Train")

local TrainingDropdown = Tabs.AutoFight:AddDropdown("TrainingSelect", {
    Title = "Select Training Type",
    Values = {"Dumbells", "PunchBags", "Grips", "Barbells"}, 
    Multi = false,
    Default = "Dumbells"
})

local AutoTrainToggle = Tabs.AutoFight:AddToggle("AutoTrain", {
    Title = "Auto Train",
    Description = "If this gets an error, turn the toggle off and on again. It occurs when you switch training types with the toggle on :)",
    Default = false
})

-- Variable to store the current training equipment type
local currentTrainingType = nil

AutoTrainToggle:OnChanged(function()
    if AutoTrainToggle.Value then
        -- Store the selected training type when starting
        currentTrainingType = TrainingDropdown.Value
        
        spawn(function()
            local currentZone = GetCurrentZone()
            
            if not currentZone then
                return
            end
            
            if currentTrainingType == "Dumbells" then
                -- Function to equip Dumbells
                local function equipDumbells()
                    local equipment = GetBestDuckEquipment("Dumbells")
                    local args = {
                        [1] = currentZone,
                        [2] = "Dumbells", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipDumbells()

                -- Click loop (every 0.1 seconds for faster gains)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.1)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" then
                        equipDumbells()
                    end
                end
                
            elseif currentTrainingType == "Grips" then
                -- Function to equip Grips
                local function equipGrips()
                    local equipment = GetBestDuckEquipment("Grips")
                    local args = {
                        [1] = currentZone,
                        [2] = "Grips", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipGrips()

                -- Click loop (every 0.1 seconds for faster gains)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.1)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" then
                        equipGrips()
                    end
                end
                
            elseif currentTrainingType == "Barbells" then
                -- Function to equip Barbells
                local function equipBarbells()
                    local equipment = GetBestDuckEquipment("Barbells")
                    local args = {
                        [1] = currentZone,
                        [2] = "Barbells", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipBarbells()

                -- Click loop (every 0.1 seconds for faster gains)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.1)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" then
                        equipBarbells()
                    end
                end
            else -- PunchBags
                spawn(function() 
                    local lastTeleport = 0
                    while AutoTrainToggle.Value and currentTrainingType == "PunchBags" and TrainingDropdown.Value == "PunchBags" do
                        local tier = GetBestDuckBag()
                        
                        -- Try to get the bag from workspace
                        local bag = workspace.Zones[currentZone].Interactables.Training.PunchBags:FindFirstChild(tier)
                        
                        if bag then
                            -- Only teleport every 5 seconds
                            local currentTime = tick()
                            if currentTime - lastTeleport >= 5 then
                                local bagCFrame = bag:GetPivot()
                                game.Players.LocalPlayer.Character:PivotTo(bagCFrame * CFrame.new(0, 0, -5))
                                lastTeleport = currentTime
                            end
                            
                            -- Use the punch bag service every 0.1 seconds for faster gains
                            local args = {
                                [1] = currentZone,
                                [2] = tier,
                                [3] = game.Players.LocalPlayer:GetAttribute("VIP") == true
                            }
                            game:GetService("ReplicatedStorage").Packages.Knit.Services.PunchBagService.RE.onGiveStats:FireServer(unpack(args))
                        end
                        wait(0.1)
                    end
                end)
            end
        end)
    else
        -- Clear the current training type when stopping
        currentTrainingType = nil
    end
end)

-- Listen for dropdown value changes to update currentTrainingType when needed
TrainingDropdown:OnChanged(function()
    if AutoTrainToggle.Value then
        -- If toggle is on, update current training and restart the training process
        AutoTrainToggle:Set(false) -- Turn off current training
        wait(0.1) -- Short delay to ensure loops are terminated
        AutoTrainToggle:Set(true) -- Turn on with new selection
    end
end)


-- UI section
local FightSection = Tabs.AutoFight:AddSection("Auto Fight")

local npcLocations = {
    SummerIsland = workspace.GameObjects.ArmWrestling.SummerIsland.NPC,
}

local modelNames = {}
local npcZones = {}
local npcModels = {} -- Store actual NPC model by name

-- Gather NPCs from all locations
for zone, path in pairs(npcLocations) do
    for _, npc in pairs(path:GetChildren()) do
        if npc:IsA("Model") then
            table.insert(modelNames, npc.Name)
            npcZones[npc.Name] = zone
            npcModels[npc.Name] = npc -- Store model reference
        end
    end
end

table.sort(modelNames)

-- Dropdown
local modelDropdown = Tabs.AutoFight:AddDropdown("ModelDropdown", {
    Title = "Select Boss",
    Values = modelNames,
    Multi = false,
    Searchable = true,
    Default = modelNames[1] or "",
})

-- Auto Click toggle
local AutoClickToggle = Tabs.AutoFight:AddToggle("AutoClick", {
    Title = "Auto Click/Crit",
    Description = "Allows you to win fights over 5x as fast.",
    Default = false
})

-- Auto Fight toggle
local AutoFightToggle = Tabs.AutoFight:AddToggle("AutoFight", {
    Title = "Auto Fight",
    Description = "Automatically starts fights with the selected boss (to beat bosses much faster, enable the Auto Click/Crit toggle).",
    Default = false
})

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local KnitServices = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
local ArmwrestleServiceRF = KnitServices:WaitForChild("ArmWrestleService"):WaitForChild("RF")

-- Variables
local autoClickThreads = {}
local autoFightLoop = nil

-- Returns NPC instance based on selected name
local function getNPCReference(selectedName)
    return npcModels[selectedName]
end

-- Auto Click toggle handler
AutoClickToggle:OnChanged(function()
    if AutoClickToggle.Value then
        -- Clear any previous threads
        for _, thread in pairs(autoClickThreads) do
            if typeof(thread) == "thread" then
                task.cancel(thread)
            elseif typeof(thread) == "table" then
                thread.active = false
            end
        end
        autoClickThreads = {}

        task.spawn(function()
            for i = 1, 150 do -- Consider reducing this for performance
                local threadData = { active = true }
                table.insert(autoClickThreads, threadData)

                task.spawn(function()
                    while threadData.active and AutoClickToggle.Value do
                        pcall(function()
                            ArmwrestleServiceRF:WaitForChild("RequestClick"):InvokeServer()
                            ArmwrestleServiceRF:WaitForChild("RequestCritHit"):InvokeServer()
                        end)
                        task.wait()
                    end
                end)

                task.wait()
            end
        end)
    else
        -- Disable all click threads
        for _, thread in pairs(autoClickThreads) do
            if typeof(thread) == "thread" then
                task.cancel(thread)
            elseif typeof(thread) == "table" then
                thread.active = false
            end
        end
        autoClickThreads = {}
    end
end)

-- Auto Fight toggle handler
AutoFightToggle:OnChanged(function()
    if AutoFightToggle.Value then
        if autoFightLoop then task.cancel(autoFightLoop) end
        autoFightLoop = task.spawn(function()
            while AutoFightToggle.Value do
                local selectedName = modelDropdown.Value
                if selectedName then
                    local npcModel = getNPCReference(selectedName)
                    if npcModel then
                        pcall(function()
                            ArmwrestleServiceRF:WaitForChild("RequestStartFight"):InvokeServer(npcModel)
                        end)
                    end
                end
                task.wait(0.5) -- fight every 0.5s
            end
        end)
    else
        if autoFightLoop then
            task.cancel(autoFightLoop)
            autoFightLoop = nil
        end
    end
end)

local EggSection = Tabs.Eggs:AddSection("Eggs")

-- Hatch Amount Dropdown
local HatchAmountDropdown = Tabs.Eggs:AddDropdown("HatchAmount", {
    Title = "Hatch Amount",
    Values = {"1x", "3x", "8x", "30x", "Max"},
    Multi = false,
    Default = "1x"
})

-- Egg Selection Dropdown (Populated Dynamically)
local eggNames = getEggNames()
local EggDropdown = Tabs.Eggs:AddDropdown("EggSelect", {
    Title = "Select Egg",
    Values = eggNames,
    Multi = false,
    Default = eggNames[1] or "None"
})

-- Auto Hatch Toggle
local AutoHatchToggle = Tabs.Eggs:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Default = false
})

-- Utility function to check if egg is inside RotatingEggs
local function isRotatingEgg(eggName)
    local rotatingEggs = workspace:FindFirstChild("GameObjects") and workspace.GameObjects:FindFirstChild("RotatingEggs")
    if not rotatingEggs then return false end
    return rotatingEggs:FindFirstChild(eggName) ~= nil
end

AutoHatchToggle:OnChanged(function()
    if AutoHatchToggle.Value then
        spawn(function()
            while AutoHatchToggle.Value do
                local selectedEgg = EggDropdown.Value
                local hatchMultiplier = HatchAmountDropdown.Value

                local args = {}

                local rotating = isRotatingEgg(selectedEgg)

                if rotating then
                    -- Use 7th arg = true for rotating eggs (like 2x luck eggs)
                    if hatchMultiplier == "1x" then
                        args = {selectedEgg, nil, nil, false, nil, nil, true}
                    elseif hatchMultiplier == "3x" then
                        args = {selectedEgg, nil, true, false, nil, nil, true}
                    elseif hatchMultiplier == "8x" then
                        args = {selectedEgg, nil, false, true, true, nil, true}
                    elseif hatchMultiplier == "30x" then
                        args = {selectedEgg, nil, nil, false, nil, true, true}
                    elseif hatchMultiplier == "Max" then
                        args = {selectedEgg, nil, nil, false, nil, true, true}
                    end
                else
                    -- Normal hatch without 7th arg for other eggs
                    if hatchMultiplier == "1x" then
                        args = {selectedEgg, nil, nil, false, nil}
                    elseif hatchMultiplier == "3x" then
                        args = {selectedEgg, nil, true, false}
                    elseif hatchMultiplier == "8x" then
                        args = {selectedEgg, nil, false, true, true}
                    elseif hatchMultiplier == "30x" then
                        args = {selectedEgg, nil, nil, false, nil, true}
                    elseif hatchMultiplier == "Max" then
                        args = {selectedEgg, nil, nil, false, nil, true}
                    end
                end

                -- Invoke server call to hatch egg
                game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))

                wait(0.1)
            end
        end)
    end
end)

local EggStatusParagraph = Tabs.Eggs:Paragraph("EggInfo", {
    Title = "Note",
    Content = "If the egg selected has a 2x luck version, it will hatch that, and return to normal after.",
    ContentAlignment = Enum.TextXAlignment.Left
})

local WheelSection = Tabs.Wheel:AddSection("Pirate Wheel")

local GhostFortuneSpinDropdown = Tabs.Wheel:AddDropdown("GhostFortuneSpinAmount", {
    Title = "Spin Amount",
    Description = "Select Wheel Spin Amount",
    Values = {"1x", "3x", "10x"},
    Multi = false,
    Default = "1x"
})

local AutoGhostFortuneToggle = Tabs.Wheel:AddToggle("AutoGhostFortuneSpin", {
    Title = "Auto spin pirate wheel",
    Default = false
})

AutoGhostFortuneToggle:OnChanged(function()
    if AutoGhostFortuneToggle.Value then
        spawn(function()
            while true do
                if not AutoGhostFortuneToggle.Value then break end
                
                local args = {
                    [1] = "Pirate Fortune",
                    [2] = GhostFortuneSpinDropdown.Value == "3x" and "x10" or GhostFortuneSpinDropdown.Value == "10x" and "x25" or nil
                }
                game:GetService("ReplicatedStorage").Packages.Knit.Services.SpinnerService.RF.Spin:InvokeServer(unpack(args))
                
                wait(1)
            end
        end)
    end
end)


-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Packages.Knit)

-- Player
local player = Players.LocalPlayer

-- Get all possible items from LimitedMerchant module (Pirate Merchant only)
local function getAllItems()
    local LimitedMerchant = require(ReplicatedStorage.Data.LimitedMerchant)
    local allItems = {}
    local slotItemMap = {} -- Track items by slot and title to avoid duplicates
    
    local merchantName = "Pirate Merchant"
    local merchantData = LimitedMerchant[merchantName]
    
    if merchantData and merchantData.Items then
        for slotIndex, itemList in pairs(merchantData.Items) do
            for itemIndex, item in ipairs(itemList) do
                local title = item.Title or "Unknown"
                local key = merchantName .. ":" .. slotIndex .. ":" .. title
                
                -- Only add if this exact item in this slot hasn't been added yet
                if not slotItemMap[key] then
                    local itemName = string.format("%s - %s (Slot %s) (%.0f %s)",
                        title,
                        merchantName,
                        slotIndex,
                        item.Price or 0,
                        typeof(item.Currency) == "string" and item.Currency or (typeof(item.Currency) == "table" and item.Currency.Item or "Unknown Currency")
                    )
                    
                    table.insert(allItems, {
                        name = itemName,
                        merchant = merchantName,
                        slot = tonumber(slotIndex),
                        index = itemIndex,
                        raw = item
                    })
                    
                    slotItemMap[key] = true
                end
            end
        end
    end

    return allItems
end

-- Get live replica data (used to check if item is currently in merchant and has stock)
local function getLiveStockData()
    local ReplicaController = require(ReplicatedStorage.ReplicaController)
    ReplicaController.RequestData()

    local startTime = tick()
    local replica
    repeat
        task.wait(0.1)
        local CustomReplicaController = Knit.GetController("CustomReplicaController")
        replica = CustomReplicaController and CustomReplicaController:GetReplica()
    until replica or tick() - startTime > 5

    local liveData = {}
    
    if replica and replica.Data and replica.Data.LimitedMerchant then
        -- Only get data for Pirate Merchant
        local merchantName = "Pirate Merchant"
        local merchantData = replica.Data.LimitedMerchant[merchantName]
        
        if merchantData and merchantData.Items then
            for slotIndex, itemData in pairs(merchantData.Items) do
                -- Get the actual item details from the LimitedMerchant module
                local LimitedMerchant = require(ReplicatedStorage.Data.LimitedMerchant)
                local currentItem = LimitedMerchant[merchantName].Items[slotIndex][itemData.Index]
                
                -- Store more detailed information including the title for easier matching
                liveData[merchantName .. ":" .. slotIndex] = {
                    stock = itemData.Stock,
                    index = itemData.Index,
                    title = currentItem and currentItem.Title or "Unknown",
                    fullItem = currentItem
                }
            end
        end
    end

    return liveData
end

-- UI Section
local MerchantSection = Tabs.Merchant:AddSection("Pirate Merchant")

-- Get all items list and build name list + map
local allItemDataList = getAllItems()
local allItemNames = {}
local allItemDataMap = {}

for _, itemInfo in ipairs(allItemDataList) do
    table.insert(allItemNames, itemInfo.name)
    allItemDataMap[itemInfo.name] = itemInfo
end

table.sort(allItemNames)

-- Dropdown UI (before toggle)
local MerchantDropdown = MerchantSection:AddDropdown("MerchantSelect", {
    Title = "Select Pirate Merchant Item(s)",
    Description = "Choose items to auto-buy from Pirate Merchant.",
    Values = allItemNames,
    Multi = true,
    Searchable = true,
    Default = {}
})

-- Variables to hold selected items
local selectedMerchantItems = {}

-- Toggle for Auto Buying (below dropdown)
local AutoBuyToggle = MerchantSection:AddToggle("AutoBuy", {
    Title = "Auto Buy Pirate Items",
    Default = false
})

-- Paragraph to show selected items BELOW the toggle
local SelectedItemsParagraph = MerchantSection:Paragraph("SelectedItemsDisplay", {
    Title = "Selected Pirate Items",
    Content = "None selected",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Status paragraph to show recent activity
local StatusParagraph = MerchantSection:Paragraph("StatusDisplay", {
    Title = "Status",
    Content = "Waiting to start...",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Dropdown selection changed handler
MerchantDropdown:OnChanged(function(value)
    selectedMerchantItems = value

    local selectedList = {}
    for itemName, isSelected in pairs(value) do
        if isSelected then
            table.insert(selectedList, itemName)
        end
    end

    if #selectedList > 0 then
        SelectedItemsParagraph:SetValue(table.concat(selectedList, "\n"))
    else
        SelectedItemsParagraph:SetValue("None selected")
    end
end)

-- Auto Buy Loop
AutoBuyToggle:OnChanged(function(enabled)
    if enabled then
        StatusParagraph:SetValue("Starting auto-buy loop...")
        
        task.spawn(function()
            while AutoBuyToggle.Value do
                local liveData = getLiveStockData()
                local purchasesMade = false
                
                -- Check for each selected item
                for itemName, isSelected in pairs(selectedMerchantItems) do
                    if isSelected then
                        local info = allItemDataMap[itemName]
                        
                        if info then
                            local merchantName = info.merchant
                            local slot = info.slot
                            local merchantSlotKey = merchantName .. ":" .. tostring(slot)
                            local liveInfo = liveData[merchantSlotKey]
                            
                            -- Check if this slot has an item with stock
                            if liveInfo and liveInfo.stock and liveInfo.stock > 0 then
                                -- Check if the current item in this slot is the one we want to buy
                                -- Compare titles for safer matching
                                local itemTitle = info.raw.Title
                                if itemTitle == liveInfo.title then
                                    StatusParagraph:SetValue("Found selected item: " .. itemTitle .. "\nAttempting purchase...")
                                    
                                    local success, result = pcall(function()
                                        return ReplicatedStorage.Packages.Knit.Services.LimitedMerchantService.RF.BuyItem:InvokeServer(merchantName, slot)
                                    end)
                                    
                                    if success then
                                        StatusParagraph:SetValue("Successfully purchased: " .. itemTitle)
                                        purchasesMade = true
                                    else
                                        StatusParagraph:SetValue("Failed to purchase: " .. itemTitle .. "\nError: " .. tostring(result))
                                    end
                                    
                                    -- Short delay after purchasing
                                    task.wait(0.5)
                                end
                            end
                        end
                    end
                end
                
                if not purchasesMade then
                    StatusParagraph:SetValue("Checking for selected items...\nLast check: " .. os.date("%X"))
                end
                
                -- Wait before next check cycle
                task.wait(1.5)
            end
            
            StatusParagraph:SetValue("Auto-buy stopped.")
        end)
    else
        StatusParagraph:SetValue("Auto-buy disabled.")
    end
end)


-- Create fishing section in the Fish tab
local FishSection = Tabs.Fish:AddSection("Auto Fish")

-- Create toggle for auto fishing
local AutoFishToggle = Tabs.Fish:AddToggle("AutoFish", {
    Title = "Auto Fish from Anywhere",
    Description = "This will be much slower when fighting bosses."
})

-- Create status paragraph to track what was caught
local FishingStatusParagraph = Tabs.Fish:Paragraph("FishingStatus", {
    Title = "Fishing Status",
    Content = "Toggle on to start fishing",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Variables for fishing
local fishingLoops = {}
local fishStats = {
    totalCaught = 0,
    startTime = 0,
}

-- Function to update the status paragraph
local function updateFishingStatus()
    local timeElapsed = os.time() - fishStats.startTime
    local statusText = "Caught: " .. fishStats.totalCaught
    
    if timeElapsed > 0 and AutoFishToggle.Value then
        local rate = math.floor(fishStats.totalCaught / (timeElapsed / 60) * 10) / 10
        statusText = statusText .. "\nRate: " .. rate .. " fish/min"
        statusText = statusText .. "\nRunning: " .. math.floor(timeElapsed / 60) .. "m " .. timeElapsed % 60 .. "s"
    end

    -- Use pcall to safely set the value
    local success = pcall(function()
        FishingStatusParagraph:SetValue(statusText)
    end)

    -- If SetValue failed, try alternative methods
    if not success then
        pcall(function() 
            FishingStatusParagraph.Content = statusText 
        end)
    end
end


-- Function to stop all fishing loops
local function stopAutoFishing()
    -- Cancel all running threads
    for _, thread in pairs(fishingLoops) do
        if thread then
            pcall(function() task.cancel(thread) end)
        end
    end
    fishingLoops = {}
    
    -- Unequip rod
    pcall(function()
        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RF.SetFishRod:InvokeServer(false)
    end)
    
    -- Update final stats
    updateFishingStatus()
end

-- Function to record a fish catch
local function recordCatch(fishName)
    if not fishName or fishName == "" then
        fishName = "Unknown Fish"
    end
    
    fishStats.totalCaught = fishStats.totalCaught + 1
    fishStats.fishTypes[fishName] = (fishStats.fishTypes[fishName] or 0) + 1
    updateFishingStatus()
end

-- Fixed Fishing Spam Script
local function startAutoFishing()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    -- Reset statistics
    fishStats.totalCaught = 0
    fishStats.fishTypes = {}
    fishStats.startTime = os.time()
    updateFishingStatus()

    -- Get the remotes safely with pcall
    local SetFishRodRemote, StartCatchingRemote, VerifyCatchRemote
    
    pcall(function()
        SetFishRodRemote = ReplicatedStorage.Packages.Knit.Services.ToolService.RF.SetFishRod
        StartCatchingRemote = ReplicatedStorage.Packages.Knit.Services.NetService.RF.StartCatching
        VerifyCatchRemote = ReplicatedStorage.Packages.Knit.Services.NetService.RF.VerifyCatch
    end)
    
    -- Check if remotes were found
    if not (SetFishRodRemote and StartCatchingRemote and VerifyCatchRemote) then
        local statusText = "Error: Fishing remotes not found!"
        pcall(function() FishingStatusParagraph:SetValue(statusText) end)
        return
    end

    -- Hook into NetService to monitor catches
    pcall(function()
        local Knit = require(ReplicatedStorage.Packages.Knit)
        local NetService = Knit.GetService("NetService")
        if NetService and NetService.onCatch then
            NetService.onCatch:Connect(function(itemName)
                recordCatch(itemName)
            end)
        end
    end)
    
    -- Try to hook into any catch events directly
    pcall(function()
        local Knit = require(ReplicatedStorage.Packages.Knit)
        local NetController = Knit.GetController("NetController")
        if NetController then
            for k, v in pairs(NetController) do
                if type(v) == "table" and v.Connect then
                    v:Connect(function(...)
                        local args = {...}
                        if type(args[1]) == "string" then
                            recordCatch(args[1])
                        end
                    end)
                end
            end
        end
    end)

    -- Set attributes initially and periodically
    fishingLoops.attributeSetter = spawn(function()
        while AutoFishToggle.Value do
            -- Try to find fishing spots in workspace
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("Model") and (v.Name:find("Pond") or v.Name:find("Fish")) then
                    pcall(function() v:SetAttribute("Pond", "DuckPond") end)
                end
            end
            
            -- Try to set controller attributes
            pcall(function()
                local Knit = require(ReplicatedStorage.Packages.Knit)
                local NetController = Knit.GetController("NetController")
                if NetController and NetController.IsCatching then
                    NetController.IsCatching:SetAttribute("Pond", "DuckPond")
                end
            end)
            
            wait(5)
            if not AutoFishToggle.Value then break end
        end
    end)

    -- Spam equip rod and start catching
    fishingLoops.rodEquipper = spawn(function()
        while AutoFishToggle.Value do
            -- Set fishing rod
            pcall(function() 
                if SetFishRodRemote then 
                    SetFishRodRemote:InvokeServer(true, "Rod") 
                end
            end)
            
            -- Start catching
            pcall(function() 
                if StartCatchingRemote then 
                    StartCatchingRemote:InvokeServer("DuckPond") 
                end
            end)
            
            wait(1)
            if not AutoFishToggle.Value then break end
        end
    end)

    -- Spam verify catch
    fishingLoops.catchVerifier = spawn(function()
        local lastCatchTime = 0
        
        while AutoFishToggle.Value do
            -- Generate rotation values
            local rotation = math.random(1, 359)
            local barRotation = (rotation - 5) % 360
            
            -- Try to verify catch
            pcall(function() 
                if VerifyCatchRemote then 
                    local success = VerifyCatchRemote:InvokeServer(rotation, barRotation)
                    
                    -- If success is returned and significant time has passed since last catch
                    if success and tick() - lastCatchTime > 1 then
                        lastCatchTime = tick()
                        recordCatch("Fish")  -- Record catch without specific name
                    end
                end
            end)
            
            wait(0.1)
            if not AutoFishToggle.Value then break end
        end
    end)

    -- Monitor inventory for new fish (fallback method)
    fishingLoops.inventoryChecker = spawn(function()
        -- Initial inventory check
        local fishInventory = {}
        
        pcall(function()
            local Knit = require(ReplicatedStorage.Packages.Knit)
            local ReplicaController = Knit.GetController("CustomReplicaController")
            if ReplicaController then
                local replica = ReplicaController:GetReplica()
                if replica and replica.Data and replica.Data.Items and 
                   replica.Data.Items.ItemInventory and replica.Data.Items.ItemInventory.Fish then
                    -- Copy initial inventory
                    for fishName, data in pairs(replica.Data.Items.ItemInventory.Fish) do
                        fishInventory[fishName] = data["1"] or 0
                    end
                end
            end
        end)
        
        -- Check periodically for changes
        while AutoFishToggle.Value do
            wait(2)
            
            pcall(function()
                local Knit = require(ReplicatedStorage.Packages.Knit)
                local ReplicaController = Knit.GetController("CustomReplicaController")
                if ReplicaController then
                    local replica = ReplicaController:GetReplica()
                    if replica and replica.Data and replica.Data.Items and 
                       replica.Data.Items.ItemInventory and replica.Data.Items.ItemInventory.Fish then
                        -- Check for new fish or increased counts
                        for fishName, data in pairs(replica.Data.Items.ItemInventory.Fish) do
                            local currentCount = data["1"] or 0
                            local oldCount = fishInventory[fishName] or 0
                            
                            if currentCount > oldCount then
                                local newCatches = currentCount - oldCount
                                fishInventory[fishName] = currentCount
                                
                                -- Record each new catch
                                for i = 1, newCatches do
                                    recordCatch(fishName)
                                end
                            end
                        end
                    end
                end
            end)
                
            if not AutoFishToggle.Value then break end
        end
    end)

    -- Update stats periodically
    fishingLoops.statsUpdater = spawn(function()
        while AutoFishToggle.Value do
            updateFishingStatus()
            wait(1)
            if not AutoFishToggle.Value then break end
        end
    end)
end

-- Set up toggle callback
AutoFishToggle:OnChanged(function()
    if AutoFishToggle.Value then
        startAutoFishing()
    else
        stopAutoFishing()
    end
end)

local section = Tabs.Quest:AddSection("Pirate Quest")
section:AddButton({
    Title = "Complete the pirate quest",
    Description = "Instantly complete the pirate quest.",
    Callback = function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

        -- Utility: teleport player in front of a part
        local function teleportTo(part)
            if part and Character then
                Character:PivotTo(part:GetPivot() * CFrame.new(0, 0, -5))
            end
        end

        -- Utility: safely fire a prompt
        local function tryFirePrompt(target)
            if target then
                local prompt = target:FindFirstChildWhichIsA("ProximityPrompt", true)
                if prompt then
                    teleportTo(target)
                    task.wait(0.25)
                    fireproximityprompt(prompt, Character:FindFirstChild("Humanoid"))
                    return true
                end
            end
            return false
        end

        local function getQuestRoot()
            return workspace:FindFirstChild("Zones")
                and workspace.Zones:FindFirstChild("SummerIsland")
                and workspace.Zones.SummerIsland:FindFirstChild("Interactables")
                and workspace.Zones.SummerIsland.Interactables:FindFirstChild("Quest")
        end

        -- Step 1: Talk to the LostPirate NPC (start quest)
        local questRoot = getQuestRoot()
        local lostPirate = questRoot and questRoot:FindFirstChild("LostPirate")
        if tryFirePrompt(lostPirate) then
            print("Started Pirate Quest")
        end

        -- Step 2: Collect 10 GoldenPlanks
        for i = 1, 10 do
            local plank = questRoot
                and questRoot:FindFirstChild("LostPirateItems")
                and questRoot.LostPirateItems:FindFirstChild("GoldenPlank" .. i)
            if plank and plank:FindFirstChild("Hitbox") then
                if tryFirePrompt(plank.Hitbox) then
                    print("Collected GoldenPlank" .. i)
                end
            end
            task.wait(0.3)
        end

        -- Step 3: Return to LostPirate to complete
        if tryFirePrompt(lostPirate) then
            print("Completed Pirate Quest")
        end
    end
})





-- Hand the library over to our managers
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes{}

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab("Settings")

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()

