-- Hero Event

-- Function to get all valid egg names in alphabetical order
local function getEggNames()
    local eggNames = {}
    local zones = workspace:FindFirstChild("Zones")

    if zones then
        for _, zone in pairs(zones:GetChildren()) do
            if zone:IsA("Folder") and not zone.Name:match("%d") then -- Ignore zones with numbers
                local interactables = zone:FindFirstChild("Interactables")
                if interactables then
                    local eggs = interactables:FindFirstChild("Eggs")
                    if eggs then
                        for _, egg in pairs(eggs:GetChildren()) do
                            table.insert(eggNames, egg.Name)
                        end
                    end
                end
            end
        end
    end

    table.sort(eggNames) -- Sort alphabetically
    return eggNames
end


game:GetService("ReplicatedStorage").Packages.Knit.Services.WrestleService.RF.OnAutoFight:InvokeServer()

-- Create a ScreenGui for our minimize button
local MinimizeGui = Instance.new("ScreenGui")
MinimizeGui.Name = "MinimizeGui"
MinimizeGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
MinimizeGui.ResetOnSpawn = false

-- Create the minimize button with centered positioning
local MinimizeButton = Instance.new("TextButton")
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Parent = MinimizeGui
MinimizeButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
MinimizeButton.BorderColor3 = Color3.fromRGB(50, 50, 50)
MinimizeButton.AnchorPoint = Vector2.new(0.5, 0.5)
MinimizeButton.Position = UDim2.new(0.5, 0, 0.5, 0)
MinimizeButton.Size = UDim2.new(0, 80, 0, 40)
MinimizeButton.Font = Enum.Font.GothamBold
MinimizeButton.Text = "Close"
MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.TextSize = 16.000

-- Add corner radius
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 6)
UICorner.Parent = MinimizeButton

-- Create X button for removal
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Parent = MinimizeButton
CloseButton.BackgroundTransparency = 1
CloseButton.Position = UDim2.new(1, -20, 0, 0)
CloseButton.Size = UDim2.new(0, 20, 0, 20)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Text = "Ã—"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 16.000
CloseButton.ZIndex = 2

-- Close button functionality
CloseButton.MouseButton1Click:Connect(function()
    -- Destroy the MinimizeButton and CloseButton
    MinimizeButton:Destroy()
    CloseButton:Destroy()
    -- Optionally, destroy the entire GUI if needed
    MinimizeGui:Destroy()
end)



-- Make button draggable
local UserInputService = game:GetService("UserInputService")
local dragging
local dragStart
local startPos

MinimizeButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = MinimizeButton.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
        local delta = input.Position - dragStart
        MinimizeButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Add hover effects for Event button
MinimizeButton.MouseEnter:Connect(function()
    game:GetService("TweenService"):Create(MinimizeButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    }):Play()
end)

MinimizeButton.MouseLeave:Connect(function()
    game:GetService("TweenService"):Create(MinimizeButton, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    }):Play()
end)

-- Add hover effects for close button
CloseButton.MouseEnter:Connect(function()
    game:GetService("TweenService"):Create(CloseButton, TweenInfo.new(0.2), {
        TextColor3 = Color3.fromRGB(255, 100, 100)
    }):Play()
end)

CloseButton.MouseLeave:Connect(function()
    game:GetService("TweenService"):Create(CloseButton, TweenInfo.new(0.2), {
        TextColor3 = Color3.fromRGB(255, 255, 255)
    }):Play()
end)

-- Add shadow
local Shadow = Instance.new("ImageLabel")
Shadow.Name = "Shadow"
Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
Shadow.BackgroundTransparency = 1
Shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
Shadow.Size = UDim2.new(1, 10, 1, 10)
Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
Shadow.ImageTransparency = 0.5
Shadow.Image = "rbxassetid://7912134082"
Shadow.Parent = MinimizeButton
Shadow.ZIndex = MinimizeButton.ZIndex - 1
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/Main.lua"))()
-- Create window with proper callbacks
local Window = Fluent:CreateWindow({
    Title = "Hero Event",
    SubTitle = "By Duckie",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl,
    OnDestroy = function()
        local fadeOut = game:GetService("TweenService"):Create(MinimizeGui, TweenInfo.new(0.5), {
            Transparency = 1
        })
        fadeOut:Play()
        fadeOut.Completed:Connect(function()
            MinimizeGui:Destroy()
        end)
    end
})

local Tabs = {
    Event = Window:AddTab({ Title = "Hero", Icon = "flame" })

}

-- Initialize state
local isMinimized = false
Window:Minimize(false)

-- Regular minimize/maximize functionality
MinimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    Window:Minimize(isMinimized)

    local textTween = game:GetService("TweenService"):Create(MinimizeButton, TweenInfo.new(0.2), {
        TextTransparency = 1
    })
    
    textTween:Play()
    textTween.Completed:Connect(function()
        MinimizeButton.Text = isMinimized and "Open" or "Close"
        game:GetService("TweenService"):Create(MinimizeButton, TweenInfo.new(0.2), {
            TextTransparency = 0
        }):Play()
    end)
end)

-- Close button functionality 
CloseButton.MouseButton1Click:Connect(function()
    MinimizeGui:Destroy()
    Window:Destroy()
end)


local PlaytimeSection = Tabs.Event:AddSection("Playtime Pass")

local AutoPlaytimeToggle = PlaytimeSection:AddToggle("AutoPlaytime", {
    Title = "Auto Claim Playtime Pass",
    Default = false
})

AutoPlaytimeToggle:OnChanged(function()
    if AutoPlaytimeToggle.Value then
        -- Claim rewards immediately when enabled
        for i = 1, 12 do
            local args = {
                [1] = "Free",
                [2] = i
            }
            game:GetService("ReplicatedStorage").Packages.Knit.Services.EventPassService.RF.ClaimReward:InvokeServer(unpack(args))
        end
        
        -- Start reset/claim loop
        spawn(function()
            while AutoPlaytimeToggle.Value do
                wait(60) -- Wait before reset
                
                -- Reset pass
                game:GetService("ReplicatedStorage").Packages.Knit.Services.EventPassService.RF.Reset:InvokeServer()
                
                -- Claim all rewards after reset
                for i = 1, 12 do
                    local args = {
                        [1] = "Free",
                        [2] = i
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.EventPassService.RF.ClaimReward:InvokeServer(unpack(args))
                end
            end
        end)
    end
end)

local function GetCurrentZone()
    local player = game.Players.LocalPlayer

    if player:GetAttribute("ZoneHeroCity") then
        return "HeroCity"
    end

    return nil
end

local function GetBestPrisonBag()
    local player = game.Players.LocalPlayer
    local currentZone = GetCurrentZone()
    local zoneAttributes = {
        HeroCity = "TotalSuperKnuckles"
    }
    
    local prisonKnuckle = player:GetAttribute(zoneAttributes[currentZone]) or 0
    local punchBagData = require(game:GetService("ReplicatedStorage").Data.PunchBags)
    
    if player:GetAttribute("VIP") == true then
        return "VIP"
    end
    
    local bestTier = "Tier1"  
    local highestRequired = 0
    
    if punchBagData and punchBagData[currentZone] then
        for tier, data in pairs(punchBagData[currentZone]) do
            if data.StrengthRequired and 
               prisonKnuckle >= data.StrengthRequired and 
               data.StrengthRequired > highestRequired then
                bestTier = tier
                highestRequired = data.StrengthRequired
            end
        end
    end
    
    return bestTier
end

local function GetBestPrisonEquipment()
    local player = game.Players.LocalPlayer
    local currentZone = GetCurrentZone()
    local zoneAttributes = {
        HeroCity = "TotalSuperPower",
    }
    
    local prisonBicep = player:GetAttribute(zoneAttributes[currentZone]) or 0
    local dumbbellData = require(game:GetService("ReplicatedStorage").Data.Dumbells)
    local defaultDumbbells = {
        HeroCity = "HeroCity1"
    }
    
    local bestDumbell = defaultDumbbells[currentZone]
    local highestRequired = 0
    
    if dumbbellData and dumbbellData[currentZone] then
        for name, data in pairs(dumbbellData[currentZone]) do
            if data.StrengthRequired and 
               prisonBicep >= data.StrengthRequired and 
               data.StrengthRequired > highestRequired then
                bestDumbell = name
                highestRequired = data.StrengthRequired
            end
        end
    end

    return bestDumbell
end


-- Add Training Section
local TrainSection = Tabs.Event:AddSection("Auto Train")

local TrainingDropdown = Tabs.Event:AddDropdown("TrainingSelect", {
    Title = "Select Training Type",
    Values = {"Dumbells", "PunchBags"}, 
    Multi = false,
    Default = "Dumbells"
})

local AutoTrainToggle = Tabs.Event:AddToggle("AutoTrain", {
    Title = "Auto Train",
    Default = false
})

AutoTrainToggle:OnChanged(function()
    if AutoTrainToggle.Value then
        spawn(function()
            if TrainingDropdown.Value == "Dumbells" then
                -- Function to equip Dumbells
                local function equipDumbells()
                    local currentZone = GetCurrentZone()
                    local equipment = GetBestPrisonEquipment()
                    local args = {
                        [1] = currentZone,
                        [2] = "Dumbells", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipDumbells()

                -- Click loop (every 0.2 seconds)
                spawn(function()
                    while AutoTrainToggle.Value do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.2)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value then
                        equipDumbells()
                    end
                end

            else -- PunchBags
                spawn(function() 
                    while AutoTrainToggle.Value do
                        local currentZone = GetCurrentZone()
                        local tier = GetBestPrisonBag()
                        local bag = workspace.Zones[currentZone].Interactables.Training.PunchBags[tier]
                        
                        if bag then
                            local bagCFrame = bag:GetPivot()
                            game.Players.LocalPlayer.Character:PivotTo(bagCFrame * CFrame.new(0, 0, -5))
                            
                            local args = {
                                [1] = currentZone,
                                [2] = tier,
                                [3] = game.Players.LocalPlayer:GetAttribute("VIP") == true
                            }
                            game:GetService("ReplicatedStorage").Packages.Knit.Services.PunchBagService.RE.onGiveStats:FireServer(unpack(args))
                        end
                        wait(0.25)
                    end
                end)
            end
        end)
    end
end)





-- Auto Fight Section
local FightSection = Tabs.Event:AddSection("Auto Fight")

local npcLocations = {
    HeroCity = workspace.GameObjects.ArmWrestling.HeroCity.NPC
}

local modelNames = {}
local models = {}
local npcZones = {} -- Store which zone each NPC belongs to

-- Gather NPCs from all locations
for zone, path in pairs(npcLocations) do
    for _, npc in pairs(path:GetChildren()) do
        if npc:IsA("Model") then
            table.insert(models, npc)
            table.insert(modelNames, npc.Name)
            npcZones[npc.Name] = zone
        end
    end
end

table.sort(modelNames)

local modelDropdown = Tabs.Event:AddDropdown("ModelDropdown", {
    Title = "Select Boss",
    Values = modelNames,
    Multi = false,
    Default = modelNames[1]
})

local AutoFightToggle = Tabs.Event:AddToggle("AutoFight", {
    Title = "Auto Fight",
    Default = false
})

AutoFightToggle:OnChanged(function()
    if AutoFightToggle.Value then
        spawn(function()
            while AutoFightToggle.Value do
                local selectedNPC = modelDropdown.Value
                if selectedNPC then
                    local zone = npcZones[selectedNPC]
                    local npcPath = npcLocations[zone]
                    
                    if npcPath then
                        local npcModel = npcPath:FindFirstChild(selectedNPC)
                        if npcModel and npcModel:FindFirstChild("Table") then
                            local args = {
                                [1] = selectedNPC,
                                [2] = npcModel.Table,
                                [3] = zone
                            }
                            game:GetService("ReplicatedStorage").Packages.Knit.Services.ArmWrestleService.RE.onEnterNPCTable:FireServer(unpack(args))
                        end
                    end
                end
                wait(1)
            end
        end)
    end
end)

local AutoClickToggle = Tabs.Event:AddToggle("AutoClick", {
    Title = "Auto Click", 
    Default = false 
})

AutoClickToggle:OnChanged(function()
    if AutoClickToggle.Value then
        spawn(function()
            while true do
                if not AutoClickToggle.Value then break end
                game:GetService("ReplicatedStorage").Packages.Knit.Services.ArmWrestleService.RE.onClickRequest:FireServer()
                wait(0.1)
            end
        end)
    end
end)


local NPCSection = Tabs.Event:AddSection("Auto Fight Npcs")

-- Storage for NPC data
local npcData = {}
local zoneIDs = {}
local selectedZone = nil

-- Function to discover Zone IDs from game data
local function DiscoverZoneIDs()
    local discoveredZones = {}
    
    -- Get necessary controllers
    pcall(function()
        local Knit = require(game.ReplicatedStorage.Packages.Knit)
        local CacheController = Knit.GetController("CacheController")
        local cache = CacheController:GetCache()
        
        -- Get Zone IDs directly from cache data
        if cache and cache.Data and cache.Data.RngZones then
            for zoneID, _ in pairs(cache.Data.RngZones) do
                table.insert(discoveredZones, zoneID)
            end
        end
    end)
    
    -- Sort the array
    table.sort(discoveredZones)
    
    if #discoveredZones == 0 then
        table.insert(discoveredZones, "Unknown")
    end
    
    return discoveredZones
end

-- Function to update NPC IDs
local function UpdateNPCIDs()
    -- Clear previous data
    npcData = {}
    
    -- Get necessary controllers
    local Knit = require(game.ReplicatedStorage.Packages.Knit)
    local CacheController = Knit.GetController("CacheController")
    local cache = CacheController:GetCache()
    
    -- Get IDs from cache data
    if cache and cache.Data and cache.Data.RngZones then
        for zoneID, zoneNPCs in pairs(cache.Data.RngZones) do
            -- Initialize data for this zone
            npcData[zoneID] = {}
            
            -- Store all NPC IDs for this zone
            for npcID, _ in pairs(zoneNPCs) do
                table.insert(npcData[zoneID], npcID)
            end
        end
    end
end

-- Function to extract NPC name from zone ID
local function ExtractNPCNameFromZoneID(zoneID)
    local parts = string.split(zoneID, "-")
    if #parts > 1 then
        return parts[2]
    end
    return zoneID -- Return original if no dash is found
end

-- Function to safely find NPC table
local function FindNPCTable(zoneID, npcName)
    -- Try to find the zone
    local RngNPCs = workspace:FindFirstChild("GameObjects")
    if not RngNPCs then return nil end
    
    RngNPCs = RngNPCs:FindFirstChild("RngNPCs")
    if not RngNPCs then return nil end
    
    local zoneFolder = RngNPCs:FindFirstChild(zoneID)
    if not zoneFolder then return nil end
    
    -- Check different path possibilities to find the table
    
    -- First attempt: Direct path to NPC table
    if zoneFolder:FindFirstChild("Npc") and 
       zoneFolder.Npc:FindFirstChild(npcName) and 
       zoneFolder.Npc[npcName]:FindFirstChild("Table") then
        return zoneFolder.Npc[npcName].Table
    end
    
    -- Second attempt: NPC might be direct child with table
    if zoneFolder:FindFirstChild(npcName) and 
       zoneFolder[npcName]:FindFirstChild("Table") then
        return zoneFolder[npcName].Table
    end
    
    -- Third attempt: Look through all children for the first table
    for _, child in pairs(zoneFolder:GetDescendants()) do
        if child.Name == "Table" then
            return child
        end
    end
    
    return nil
end

-- Function to get the correct proximity prompt path based on NPC selection
local function getProximityPromptPath()
    local evilLairNPCs = {
        ["Dreadlord"] = true,
        ["Skullbane"] = true,
        ["Spectron"] = true,
        ["Vortex"] = true
    }
    
    local npcName = ExtractNPCNameFromZoneID(selectedZone)
    
    if evilLairNPCs[npcName] then
        return workspace.GameObjects.RngNPCs["EvilLair-" .. npcName].Npc:GetChildren()[4].Table.Proximity.Attachment.ProximityPrompt
    else
        -- For Phantom, Radiance, and Inferno
        return workspace.GameObjects.RngNPCs["SuperheroCity-" .. npcName].Npc[npcName].Table.Proximity.Attachment.ProximityPrompt
    end
end

-- Initial discovery of Zone IDs
zoneIDs = DiscoverZoneIDs()

-- Initial NPC data update
UpdateNPCIDs()

-- Create dropdown with discovered Zone IDs
selectedZone = zoneIDs[1]
local NPCDropdown = NPCSection:AddDropdown("NPCSelection", {
    Title = "Select NPC",
    Description = "Select an NPC to fight.",
    Values = zoneIDs,
    Default = 1,
})

NPCDropdown:OnChanged(function(Value)
    selectedZone = Value
end)

-- Toggle for auto fighting
local AutoFightNPCToggle = NPCSection:AddToggle("AutoFightNPC", {
    Title = "Auto Fight NPC",
    Description = "Automatically fight the selected NPC.",
    Default = false
})

-- Add the emergency button to handle stuck situations
local EmergencyButton = NPCSection:AddButton({
    Title = "Press if you're stuck fighting an NPC",
    Description = "When turning the toggle off you will likely get stuck, press this to fix it",
    Callback = function()
        pcall(function()
            local prompt = getProximityPromptPath()
            if prompt then
                fireproximityprompt(prompt)
            end
        end)
    end
})

-- Auto fight function
AutoFightNPCToggle:OnChanged(function()
    local isEnabled = AutoFightNPCToggle.Value
    
    spawn(function()
        while AutoFightNPCToggle.Value do
            -- Update NPC IDs every 1.5 seconds
            UpdateNPCIDs()
            
            -- Get an NPC ID for the selected zone
            if npcData[selectedZone] and #npcData[selectedZone] > 0 then
                -- Get a random entry to avoid always using the same one
                local randomIndex = math.random(1, #npcData[selectedZone])
                local npcID = npcData[selectedZone][randomIndex]
                
                -- Call the remote function to fight NPC
                pcall(function()
                    local args = {
                        [1] = selectedZone,
                        [2] = npcID
                    }
                    
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.WrestleRNGService.RF.FightNpc:InvokeServer(unpack(args))
                end)
                
                -- Wait a brief moment before entering the table
                wait(0.2)
                
                -- Extract NPC name from the zone ID
                local npcName = ExtractNPCNameFromZoneID(selectedZone)
                
                -- Find the table object safely
                local tableObject = FindNPCTable(selectedZone, npcName)
                
                -- Only proceed if we found the table
                if tableObject then
                    pcall(function()
                        local tableArgs = {
                            [1] = npcName,
                            [2] = tableObject
                        }
                        
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ArmWrestleService.RE.onEnterNPCTable:FireServer(unpack(tableArgs))
                    end)
                end
            end
            
            -- Wait 1.5 seconds before updating and trying again
            wait(1.5)
        end
    end)
end)




-- Eggs Section
local EggSection = Tabs.Event:AddSection("Eggs")

-- Hatch Amount Dropdown
local HatchAmountDropdown = Tabs.Event:AddDropdown("HatchAmount", {
    Title = "Hatch Amount",
    Values = {"1x", "3x", "8x", "30x", "Max"},
    Multi = false,
    Default = "1x"
})

-- Egg Selection Dropdown (Populated Dynamically)
local eggNames = getEggNames()
local EggDropdown = Tabs.Event:AddDropdown("EggSelect", {
    Title = "Select Egg",
    Values = eggNames,
    Multi = false,
    Default = eggNames[1] or "None"
})

-- Auto Hatch Toggle
local AutoHatchToggle = Tabs.Event:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Default = false
})

AutoHatchToggle:OnChanged(function()
    if AutoHatchToggle.Value then
        spawn(function()
            while true do
                if not AutoHatchToggle.Value then break end

                local args = {}
                local selectedEgg = EggDropdown.Value
                local hatchMultiplier = HatchAmountDropdown.Value

                if hatchMultiplier == "1x" then
                    args = {selectedEgg, nil, nil, false, nil}
                elseif hatchMultiplier == "3x" then
                    args = {selectedEgg, nil, true, false}
                elseif hatchMultiplier == "8x" then
                    args = {selectedEgg, nil, false, true, true}
                elseif hatchMultiplier == "30x" then
                    args = {selectedEgg, nil, nil, false, nil, true}
                elseif hatchMultiplier == "Max" then
                    args = {selectedEgg, nil, nil, false, nil, true}
                end

                game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))
                wait(0.001)
            end
        end)
    end
end)

localClickChestSection = Tabs.Event:AddSection("Giga Hero chest")

local AutoClickToggle = Tabs.Event:AddToggle("AutoClickToggle", {
    Title = "Auto Click Giga Hero Chest",
    Default = false
})

-- Auto-click functionality
AutoClickToggle:OnChanged(function()
    if AutoClickToggle.Value then
        -- Set click detector max distance to very high value
        local clickDetector = workspace.GameObjects.GigaChest.HeroChest.Chest.ClickDetector
        if clickDetector then
            clickDetector.MaxActivationDistance = 10200393949349
        end
        
        -- Start auto-clicking
        spawn(function()
            while true do
                if not AutoClickToggle.Value then break end
                
                -- Click the detector
                local clickDetector = workspace.GameObjects.GigaChest.HeroChest.Chest.ClickDetector
                if clickDetector then
                    fireclickdetector(clickDetector)
                end
                
                wait(0.1) -- Wait 0.1 seconds before next click
            end
        end)
    end
end)

local AutoUpgradeSection = Tabs.Event:AddSection("Auto Upgrade")

-- Power Multiplier Toggle
local PowerMultiplierToggle = AutoUpgradeSection:AddToggle("PowerMultiplier", {
    Title = "Power Multiplier",
    Description = "Auto upgrade Super Power Multiplier",
    Default = false
})

PowerMultiplierToggle:OnChanged(function()
    if PowerMultiplierToggle.Value then
        spawn(function()
            while PowerMultiplierToggle.Value do
                -- Buy 3 times with 1 second delay
                for i = 1, 3 do
                    local args = {
                        [1] = "Super Power Multiplier"
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.HeroUpgradeService.RF.BuyUpgrade:InvokeServer(unpack(args))
                    wait(1)
                end
                
                -- Wait 10 seconds before repeating
                wait(30)
            end
        end)
    end
end)

-- Knuckles Multiplier Toggle
local KnucklesMultiplierToggle = AutoUpgradeSection:AddToggle("KnucklesMultiplier", {
    Title = "Knuckles Multiplier",
    Description = "Auto upgrade Super Knuckles Multiplier",
    Default = false
})

KnucklesMultiplierToggle:OnChanged(function()
    if KnucklesMultiplierToggle.Value then
        spawn(function()
            while KnucklesMultiplierToggle.Value do
                -- Buy 3 times with 1 second delay
                for i = 1, 3 do
                    local args = {
                        [1] = "Super Knuckles Multiplier"
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.HeroUpgradeService.RF.BuyUpgrade:InvokeServer(unpack(args))
                    wait(1)
                end
                
                -- Wait 10 seconds before repeating
                wait(30)
            end
        end)
    end
end)

-- Coins Multiplier Toggle
local CoinsMultiplierToggle = AutoUpgradeSection:AddToggle("CoinsMultiplier", {
    Title = "Coins Multiplier",
    Description = "Auto upgrade Super Coin Multiplier",
    Default = false
})

CoinsMultiplierToggle:OnChanged(function()
    if CoinsMultiplierToggle.Value then
        spawn(function()
            while CoinsMultiplierToggle.Value do
                -- Buy 3 times with 1 second delay
                for i = 1, 3 do
                    local args = {
                        [1] = "Super Coin Multiplier"
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.HeroUpgradeService.RF.BuyUpgrade:InvokeServer(unpack(args))
                    wait(1)
                end
                
                -- Wait 10 seconds before repeating
                wait(30)
            end
        end)
    end
end)

-- Gem Chance Toggle
local GemChanceToggle = AutoUpgradeSection:AddToggle("GemChance", {
    Title = "Gem Chance",
    Description = "Auto upgrade Gem Chance Multiplier",
    Default = false
})

GemChanceToggle:OnChanged(function()
    if GemChanceToggle.Value then
        spawn(function()
            while GemChanceToggle.Value do
                -- Buy 3 times with 1 second delay
                for i = 1, 3 do
                    local args = {
                        [1] = "Gem Chance Multiplier"
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.HeroUpgradeService.RF.BuyUpgrade:InvokeServer(unpack(args))
                    wait(1)
                end
                
                -- Wait 10 seconds before repeating
                wait(30)
            end
        end)
    end
end)

local MerchantSection = Tabs.Event:AddSection("Merchant")

local BlackMarketDropdown = Tabs.Event:AddDropdown("BlackMarketDropdown", {
    Title = "Select Merchant Slot(s)",
    Values = {1, 2, 3, 4, 5},
    Multi = true,
    Default = {}
})

local AutoBuyToggle = Tabs.Event:AddToggle("AutoBuyToggle", {
    Title = "Auto Buy (Selected Slots)",
    Default = false
})

AutoBuyToggle:OnChanged(function()
    if AutoBuyToggle.Value then
        spawn(function()
            while true do
                if not AutoBuyToggle.Value then break end
                -- Buy 3 times
                for i = 1, 3 do
                    for number, isSelected in pairs(BlackMarketDropdown.Value) do
                        if isSelected then
                            local args = {
                                [1] = "Evil Merchant",
                                [2] = number
                            }
                            game:GetService("ReplicatedStorage").Packages.Knit.Services.LimitedMerchantService.RF.BuyItem:InvokeServer(unpack(args))
                            wait(1)
                        end
                    end
                end
                wait(30) -- Wait 30 seconds before next cycle
            end
        end)
    end
end)


local HeroSpeedrunSection = Tabs.Event:AddSection("Hero Speedrun")

-- Toggle state tracking
local wasAutoFightOn = false
local wasAutoBeatNPCOn = false
local wasAutoTrainOn = false

-- Add Status Label for cooldown
local HeroSpeedrunStatus = HeroSpeedrunSection:AddParagraph({
    Title = "Hero Speedrun Cooldown",
    Content = "Loading..."
})

-- Update status every second
spawn(function()
    while true do
        local success, timerGui = pcall(function()
            return workspace.GameObjects.Minigames.SpeedrunMinigames.HeroSpeedrun.Visual.BillboardGui.Timer
        end)
        
        if success and timerGui then
            HeroSpeedrunStatus:SetDesc(timerGui.Text)
        else
            HeroSpeedrunStatus:SetDesc("Waiting for timer...")
        end
        wait(1)
    end
end)

local AutoHeroSpeedrunToggle = HeroSpeedrunSection:AddToggle("AutoHeroSpeedrun", {
    Title = "Auto Hero Speedrun",
    Description = "Auto join the Hero Speedrun. It will temporarily turn off the toggles for Auto Fight, Auto Beat NPC, and Auto Train if you had them enabled. It will return them to their previous state after the speedrun.",
    Default = false
})

AutoHeroSpeedrunToggle:OnChanged(function()
    if AutoHeroSpeedrunToggle.Value then
        spawn(function()
            while AutoHeroSpeedrunToggle.Value do
                local success, timerGui = pcall(function()
                    return workspace.GameObjects.Minigames.SpeedrunMinigames.HeroSpeedrun.Visual.BillboardGui.Timer
                end)
                
                if success and timerGui then
                    if timerGui.Text == "Touch to play!" then
                        -- Store toggle states if they haven't been stored yet
                        if not wasAutoFightOn and not wasAutoBeatNPCOn and not wasAutoTrainOn then
                            wasAutoFightOn = AutoFightToggle and AutoFightToggle.Value or false
                            wasAutoBeatNPCOn = AutoFightNPCToggle and AutoFightNPCToggle.Value or false 
                            wasAutoTrainOn = AutoTrainToggle and AutoTrainToggle.Value or false
                        end

                        -- Disable toggles with retry
                        local function disableToggle(toggle)
                            if toggle and toggle.Value then
                                for i = 1, 3 do
                                    toggle:SetValue(false)
                                    wait(1)
                                    if not toggle.Value then break end
                                end
                            end
                        end

                        disableToggle(AutoFightToggle)
                        disableToggle(AutoFightNPCToggle)
                        disableToggle(AutoTrainToggle)

                        wait(3) -- Wait before joining the speedrun

                        -- Join speedrun
                        local args = {
                            [1] = "HeroSpeedrun"
                        }
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.SpeedrunMinigameService.RF.EnterSpeedrun:InvokeServer(unpack(args))
                        
                        -- Teleport to the ending
                        local player = game:GetService("Players").LocalPlayer
                        local character = player.Character or player.CharacterAdded:Wait()
                        local hrp = character:WaitForChild("HumanoidRootPart")
                        
                        local ending = workspace.GameObjects.Minigames.SpeedrunMinigames.HeroSpeedrun.Ending
                        if ending then
                            hrp.CFrame = ending.CFrame
                        end
                        
                        wait(5) -- Wait after completion before re-enabling toggles
                    else
                        -- Restore toggles only if the timer is not "Ready!" and we previously saved states
                        if wasAutoFightOn or wasAutoBeatNPCOn or wasAutoTrainOn then
                            local function enableToggle(toggle, state)
                                if state and toggle and not toggle.Value then
                                    for i = 1, 3 do
                                        toggle:SetValue(true)
                                        wait(0.1)
                                        if toggle.Value then break end
                                    end
                                end
                            end
                            
                            wait(3) -- Wait before re-enabling toggles
                            
                            enableToggle(AutoFightToggle, wasAutoFightOn)
                            enableToggle(AutoFightNPCToggle, wasAutoBeatNPCOn)
                            enableToggle(AutoTrainToggle, wasAutoTrainOn)

                            -- Reset stored states after restoring
                            wasAutoFightOn = false
                            wasAutoBeatNPCOn = false
                            wasAutoTrainOn = false
                        end
                    end
                end
                wait(1)
            end
        end)
    end
end)


local TowerSection = Tabs.Event:AddSection("Towers")

-- Prison Cave Buttons
TowerSection:AddButton({
    Title = "Use Villain Hideout Key (1x)",
    Description = "Use the Villain Hideout Key once.",
    Callback = function()
        local args = {
            [1] = "VillainHideout",
            [2] = false
        }
        game:GetService("ReplicatedStorage").Packages.Knit.Services.TowerService.RF.EnterTower:InvokeServer(unpack(args))
    end
})

TowerSection:AddButton({
    Title = "Use All Villain Hideout Keys (250x)",
    Description = "Use All Villain Hideout Keys (max 250 at a time).",
    Callback = function()
        local args = {
            [1] = "VillainHideout",
            [2] = true
        }
        game:GetService("ReplicatedStorage").Packages.Knit.Services.TowerService.RF.EnterTower:InvokeServer(unpack(args))
    end
})



local WheelSection = Tabs.Event:AddSection("Bulk Smash Wheel")

local GhostFortuneSpinDropdown = Tabs.Event:AddDropdown("GhostFortuneSpinAmount", {
    Title = "Spin Amount",
    Description = "Select Wheel Spin Amount",
    Values = {"1x", "3x", "10x"},
    Multi = false,
    Default = "1x"
})

local AutoGhostFortuneToggle = Tabs.Event:AddToggle("AutoGhostFortuneSpin", {
    Title = "Auto Bulk Smash Fortune Wheel",
    Default = false
})

AutoGhostFortuneToggle:OnChanged(function()
    if AutoGhostFortuneToggle.Value then
        spawn(function()
            while true do
                if not AutoGhostFortuneToggle.Value then break end
                
                local args = {
                    [1] = "Bulk Smash Fortune",
                    [2] = GhostFortuneSpinDropdown.Value == "3x" and "x10" or GhostFortuneSpinDropdown.Value == "10x" and "x25" or nil
                }
                game:GetService("ReplicatedStorage").Packages.Knit.Services.SpinnerService.RF.Spin:InvokeServer(unpack(args))
                
                wait(1)
            end
        end)
    end
end)



local TreasureMapSection = Tabs.Event:AddSection("Superhero Chests")

-- Add Status Label for Captain Maps
local TreasureMapStatus = TreasureMapSection:AddParagraph({
    Title = "Hero Lightining Amount",
    Content = "Loading..."
})

-- Auto Craft Captain Chests
local AutoCraftCaptainToggle = TreasureMapSection:AddToggle("AutoCraftCaptain", {
    Title = "Auto Craft Superhero Chests",
    Description = "Automatically craft Chests (If you have 10 or more Hero Lightning",
    Default = false
})

-- Add Auto Use Captain Chests toggle
local AutoUseCaptainChestsToggle = TreasureMapSection:AddToggle("AutoUseCaptainChests", {
    Title = "Auto Use Superhero Chests",
    Description = "Automatically use Superhero chests",
    Default = false 
})

-- Add Captain Chest counter status
local CaptainChestStatus = TreasureMapSection:AddParagraph({
    Title = "Captain Chest Amount",
    Content = "Loading..."
})

-- Function to parse amount text and handle 'k' suffix
local function parseAmount(amtText)
    -- Remove the 'x' prefix
    local numStr = amtText:match("x(.+)")
    if not numStr then return 0 end
    
    -- Check if the number contains 'k'
    if numStr:find("k") then
        -- Remove 'k' and multiply by 1000
        local baseNum = tonumber(numStr:match("(%d+%.?%d*)k"))
        return baseNum and (baseNum * 1000) or 0
    else
        -- Regular number
        return tonumber(numStr) or 0
    end
end

-- Create invisible button for crafting
local player = game:GetService("Players").LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local screenGui = player.PlayerGui:WaitForChild("ScreenGui")

-- Create invisible button if it doesn't exist
local captainButton = screenGui:FindFirstChild("InvisibleCaptainButton")
if not captainButton then
    captainButton = Instance.new("TextButton")
    captainButton.Name = "InvisibleCaptainButton"
    captainButton.Size = UDim2.new(0, 200, 0, 50)
    captainButton.Position = UDim2.new(0, 100, 0, 100)
    captainButton.BackgroundTransparency = 1
    captainButton.TextTransparency = 1
    captainButton.ZIndex = -100
    captainButton.Parent = screenGui
end

-- Main functionality for auto crafting
AutoCraftCaptainToggle:OnChanged(function(value)
    if value then
        spawn(function()
            while AutoCraftCaptainToggle.Value do
                -- Check Captain Map amount
                local amtObject = player.PlayerGui.GameUI.Menus.Items.Display.Items.MainFrame.ScrollingFrame.MiscStorage.Objects:FindFirstChild("Hero Lightning/1")

                
                if amtObject then
                    local amtText = amtObject.ButtonDisplay.Amt.Text
                    local amount = parseAmount(amtText)
                    TreasureMapStatus:SetDesc(amtText)
                    
                    -- Auto craft if amount >= 10
                    if amount >= 10 then
                        -- Click the invisible button and invoke server function
                        pcall(function()
                            captainButton.MouseButton1Click:Fire()
                        end)
                        
                        -- Call the server function
                        pcall(function()
                            local args = {
                                [1] = "Superhero Chest"
                            }
                            ReplicatedStorage.Packages.Knit.Services.TreasureChestService.RF.Craft:InvokeServer(unpack(args))
                        end)
                    end
                else
                    TreasureMapStatus:SetDesc("Not Found")
                end
                
                -- Wait for 0.25 seconds before next attempt
                wait(0.25)
                
                if not AutoCraftCaptainToggle.Value then break end
            end
        end)
    end
end)

-- Update Captain Map status (runs even when auto-craft is disabled)
spawn(function()
    while true do
        local amtObject = player.PlayerGui.GameUI.Menus.Items.Display.Items.MainFrame.ScrollingFrame.MiscStorage.Objects:FindFirstChild("Hero Lightning/1")
        
        if amtObject then
            local amtText = amtObject.ButtonDisplay.Amt.Text
            TreasureMapStatus:SetDesc(amtText)
        else
            TreasureMapStatus:SetDesc("Not Found")
        end
        
        wait(1)
    end
end)

-- Update chest status and handle auto-use
spawn(function()
    while true do
        local player = game:GetService("Players").LocalPlayer
        local chestObject = player.PlayerGui.GameUI.Menus.Items.Display.Items.MainFrame.ScrollingFrame.GiftsStorage.Objects:FindFirstChild("Superhero Chest/1")
        
        if chestObject then
            local amtText = chestObject.ButtonDisplay.Amt.Text
            local amount = parseAmount(amtText)
            CaptainChestStatus:SetDesc(amtText)
            
            -- Auto use if enabled and has chests
            if AutoUseCaptainChestsToggle.Value and amount >= 1 then
                local args = {
                    [1] = {
                        ["Item"] = "Superhero Chest",
                        ["Tier"] = "1"
                    },
                    [2] = (amount >= 8) and 8 or 1 -- Use 8 if we have 8+ chests, otherwise use 1
                }
                game:GetService("ReplicatedStorage").Packages.Knit.Services.ItemService.RF.UseChest:InvokeServer(unpack(args))
            end
        else
            CaptainChestStatus:SetDesc("Not Found")
        end
        wait(1)
    end
end)

