-- Function to get all valid egg names in alphabetical order, excluding "Egg Rewind"
local function getEggNames()
    local eggNames = {}
    local zones = workspace:FindFirstChild("Zones")

    if zones then
        for _, zone in pairs(zones:GetChildren()) do
            if zone:IsA("Folder") and not zone.Name:match("%d") then -- Ignore zones with numbers
                local interactables = zone:FindFirstChild("Interactables")
                if interactables then
                    local eggs = interactables:FindFirstChild("Eggs")
                    if eggs then
                        for _, egg in pairs(eggs:GetChildren()) do
                            if egg.Name ~= "Rewind" then
                                table.insert(eggNames, egg.Name)
                            end
                        end
                    end
                end
            end
        end
    end

    table.sort(eggNames) -- Sort alphabetically
    return eggNames
end


local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()


local Window = Library:Window{
    Title = "Sumemer Event",
    SubTitle = "By Duckie",
    TabWidth = 160,
    Size =  UDim2.fromOffset(580, 460),
    Resize = false, 
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}


local Tabs = {
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
    AutoFight = Window:AddTab({ Title = "Auto Train/Fight", Icon = "crown" }),
    Eggs = Window:AddTab({ Title = "Eggs", Icon = "egg" }),
    Wheel = Window:AddTab({ Title = "Wheel", Icon = "ferris-wheel" }),
    Merchant = Window:AddTab({ Title = "Merchant", Icon = "phosphor-shopping-cart-fill" }),
    Fish = Window:AddTab({ Title = "Fish", Icon = "phosphor-fish" }),
    Fossil = Window:AddTab({ Title = "Fossils", Icon = "phosphor-bone" }),
    Quest = Window:AddTab({ Title = "Quest", Icon = "phosphor-flag" })
}





local function GetCurrentZone()
    local player = game.Players.LocalPlayer

    if player:GetAttribute("ZoneSummerIsland") then
        return "SummerIsland"
    end

    -- Look through workspace as fallback
    local duckZone = workspace.Zones:FindFirstChild("SummerIsland") or workspace.Zones:FindFirstChild("SummerIsland")
    if duckZone then
        return duckZone.Name
    end

    return nil
end

local function GetBestDuckBag()
    local player = game.Players.LocalPlayer
    local currentZone = GetCurrentZone()
    
    if not currentZone then
        return "Tier1"
    end
    
    local knuckleStrength = player:GetAttribute("TotalSummerKnucklesV2") or 0
    local punchBagData = require(game:GetService("ReplicatedStorage").Data.PunchBags)
    
    if player:GetAttribute("VIP") == true then
        return "VIP"
    end
    
    local bestTier = "Tier1"  
    local highestRequired = 0
    
    if punchBagData and punchBagData[currentZone] then
        for tier, data in pairs(punchBagData[currentZone]) do
            if data.StrengthRequired and 
               knuckleStrength >= data.StrengthRequired and 
               data.StrengthRequired > highestRequired then
                bestTier = tier
                highestRequired = data.StrengthRequired
            end
        end
    end
    
    return bestTier
end

local function GetBestDuckEquipment(equipmentType)
    local player = game.Players.LocalPlayer
    local currentZone = GetCurrentZone()
    
    if not currentZone then
        return "SummerIsland1" -- Default equipment
    end
    
    -- Determine which attribute and data to use based on equipment type
    local attributeName, dataModule, defaultEquipment
    
    
    if equipmentType == "Dumbells" then
        attributeName = "TotalSummerBicepV2"
        dataModule = "Dumbells"
        defaultEquipment = "SummerIsland1"
    elseif equipmentType == "Grips" then
        attributeName = "TotalSummerGripV2"
        dataModule = "Grips"
        defaultEquipment = "SummerIsland1"
    elseif equipmentType == "Barbells" then 
        attributeName = "TotalSummerBicepV2"
        dataModule = "Barbells"
        defaultEquipment = "SummerIsland1"
    else
        -- Default to Dumbells if unknown type
        attributeName = "TotalSummerBicepV2"
        dataModule = "Dumbells"
        defaultEquipment = "SummerIsland1"
    end
    
    
    local statValue = player:GetAttribute(attributeName) or 0
    
    local equipmentData
    pcall(function()
        equipmentData = require(game:GetService("ReplicatedStorage").Data[dataModule])
    end)
    
    if not equipmentData then
        return defaultEquipment
    end
    
    local bestEquipment = defaultEquipment
    local highestRequired = 0
    
    if equipmentData and equipmentData[currentZone] then
        for name, data in pairs(equipmentData[currentZone]) do
            if data.StrengthRequired and 
               statValue >= data.StrengthRequired and 
               data.StrengthRequired > highestRequired then
                bestEquipment = name
                highestRequired = data.StrengthRequired
            end
        end
    end

    return bestEquipment
end


-- Add Training Section
local TrainSection = Tabs.AutoFight:AddSection("Auto Train")

local TrainingDropdown = Tabs.AutoFight:AddDropdown("TrainingSelect", {
    Title = "Select Training Type",
    Values = {"Dumbells", "PunchBags", "Grips", "Barbells"}, 
    Multi = false,
    Default = "Dumbells"
})

local AutoTrainToggle = Tabs.AutoFight:AddToggle("AutoTrain", {
    Title = "Auto Train",
    Description = "If this gets an error, turn the toggle off and on again. It occurs when you switch training types with the toggle on :)",
    Default = false
})

-- Variable to store the current training equipment type
local currentTrainingType = nil

AutoTrainToggle:OnChanged(function()
    if AutoTrainToggle.Value then
        -- Store the selected training type when starting
        currentTrainingType = TrainingDropdown.Value
        
        spawn(function()
            local currentZone = GetCurrentZone()
            
            if not currentZone then
                return
            end
            
            if currentTrainingType == "Dumbells" then
                -- Function to equip Dumbells
                local function equipDumbells()
                    local equipment = GetBestDuckEquipment("Dumbells")
                    local args = {
                        [1] = currentZone,
                        [2] = "Dumbells", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipDumbells()

                -- Click loop (every 0.1 seconds for faster gains)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.1)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" then
                        equipDumbells()
                    end
                end
                
            elseif currentTrainingType == "Grips" then
                -- Function to equip Grips
                local function equipGrips()
                    local equipment = GetBestDuckEquipment("Grips")
                    local args = {
                        [1] = currentZone,
                        [2] = "Grips", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipGrips()

                -- Click loop (every 0.1 seconds for faster gains)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.1)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" then
                        equipGrips()
                    end
                end
                
            elseif currentTrainingType == "Barbells" then
                -- Function to equip Barbells
                local function equipBarbells()
                    local equipment = GetBestDuckEquipment("Barbells")
                    local args = {
                        [1] = currentZone,
                        [2] = "Barbells", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipBarbells()

                -- Click loop (every 0.1 seconds for faster gains)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.1)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" then
                        equipBarbells()
                    end
                end
            else -- PunchBags
                spawn(function() 
                    local lastTeleport = 0
                    while AutoTrainToggle.Value and currentTrainingType == "PunchBags" and TrainingDropdown.Value == "PunchBags" do
                        local tier = GetBestDuckBag()
                        
                        -- Try to get the bag from workspace
                        local bag = workspace.Zones[currentZone].Interactables.Training.PunchBags:FindFirstChild(tier)
                        
                        if bag then
                            -- Only teleport every 5 seconds
                            local currentTime = tick()
                            if currentTime - lastTeleport >= 5 then
                                local bagCFrame = bag:GetPivot()
                                game.Players.LocalPlayer.Character:PivotTo(bagCFrame * CFrame.new(0, 0, -5))
                                lastTeleport = currentTime
                            end
                            
                            -- Use the punch bag service every 0.1 seconds for faster gains
                            local args = {
                                [1] = currentZone,
                                [2] = tier,
                                [3] = game.Players.LocalPlayer:GetAttribute("VIP") == true
                            }
                            game:GetService("ReplicatedStorage").Packages.Knit.Services.PunchBagService.RE.onGiveStats:FireServer(unpack(args))
                        end
                        wait(0.1)
                    end
                end)
            end
        end)
    else
        -- Clear the current training type when stopping
        currentTrainingType = nil
    end
end)

-- Listen for dropdown value changes to update currentTrainingType when needed
TrainingDropdown:OnChanged(function()
    if AutoTrainToggle.Value then
        -- If toggle is on, update current training and restart the training process
        AutoTrainToggle:Set(false) -- Turn off current training
        wait(0.1) -- Short delay to ensure loops are terminated
        AutoTrainToggle:Set(true) -- Turn on with new selection
    end
end)


-- UI section
local FightSection = Tabs.AutoFight:AddSection("Auto Fight")

local npcLocations = {
    SummerIsland = workspace.GameObjects.ArmWrestling.SummerIsland.NPC,
}

local modelNames = {}
local npcZones = {}
local npcModels = {} -- Store actual NPC model by name

-- Gather NPCs from all locations
for zone, path in pairs(npcLocations) do
    for _, npc in pairs(path:GetChildren()) do
        if npc:IsA("Model") then
            table.insert(modelNames, npc.Name)
            npcZones[npc.Name] = zone
            npcModels[npc.Name] = npc -- Store model reference
        end
    end
end

table.sort(modelNames)

-- Dropdown
local modelDropdown = Tabs.AutoFight:AddDropdown("ModelDropdown", {
    Title = "Select Boss",
    Values = modelNames,
    Multi = false,
    Searchable = true,
    Default = modelNames[1] or "",
})

-- Auto Click toggle
local AutoClickToggle = Tabs.AutoFight:AddToggle("AutoClick", {
    Title = "Auto Click/Crit",
    Description = "Allows you to win fights over 5x as fast.",
    Default = false
})

-- Auto Fight toggle
local AutoFightToggle = Tabs.AutoFight:AddToggle("AutoFight", {
    Title = "Auto Fight",
    Description = "Automatically starts fights with the selected boss (to beat bosses much faster, enable the Auto Click/Crit toggle).",
    Default = false
})

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local KnitServices = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
local ArmwrestleServiceRF = KnitServices:WaitForChild("ArmWrestleService"):WaitForChild("RF")

-- Variables
local autoClickThreads = {}
local autoFightLoop = nil

-- Returns NPC instance based on selected name
local function getNPCReference(selectedName)
    return npcModels[selectedName]
end

-- Auto Click toggle handler
AutoClickToggle:OnChanged(function()
    if AutoClickToggle.Value then
        -- Clear any previous threads
        for _, thread in pairs(autoClickThreads) do
            if typeof(thread) == "thread" then
                task.cancel(thread)
            elseif typeof(thread) == "table" then
                thread.active = false
            end
        end
        autoClickThreads = {}

        task.spawn(function()
            for i = 1, 150 do -- Consider reducing this for performance
                local threadData = { active = true }
                table.insert(autoClickThreads, threadData)

                task.spawn(function()
                    while threadData.active and AutoClickToggle.Value do
                        pcall(function()
                            ArmwrestleServiceRF:WaitForChild("RequestClick"):InvokeServer()
                            ArmwrestleServiceRF:WaitForChild("RequestCritHit"):InvokeServer()
                        end)
                        task.wait()
                    end
                end)

                task.wait()
            end
        end)
    else
        -- Disable all click threads
        for _, thread in pairs(autoClickThreads) do
            if typeof(thread) == "thread" then
                task.cancel(thread)
            elseif typeof(thread) == "table" then
                thread.active = false
            end
        end
        autoClickThreads = {}
    end
end)

-- Auto Fight toggle handler
AutoFightToggle:OnChanged(function()
    if AutoFightToggle.Value then
        if autoFightLoop then task.cancel(autoFightLoop) end
        autoFightLoop = task.spawn(function()
            while AutoFightToggle.Value do
                local selectedName = modelDropdown.Value
                if selectedName then
                    local npcModel = getNPCReference(selectedName)
                    if npcModel then
                        pcall(function()
                            ArmwrestleServiceRF:WaitForChild("RequestStartFight"):InvokeServer(npcModel)
                        end)
                    end
                end
                task.wait(0.5) -- fight every 0.5s
            end
        end)
    else
        if autoFightLoop then
            task.cancel(autoFightLoop)
            autoFightLoop = nil
        end
    end
end)

local EggSection = Tabs.Eggs:AddSection("Eggs")

-- Hatch Amount Dropdown
local HatchAmountDropdown = Tabs.Eggs:AddDropdown("HatchAmount", {
    Title = "Hatch Amount",
    Values = {"1x", "3x", "8x", "30x", "Max"},
    Multi = false,
    Default = "1x"
})

-- Egg Selection Dropdown (Populated Dynamically)
local eggNames = getEggNames()
local EggDropdown = Tabs.Eggs:AddDropdown("EggSelect", {
    Title = "Select Egg",
    Values = eggNames,
    Multi = false,
    Default = eggNames[1] or "None"
})

-- Auto Hatch Toggle
local AutoHatchToggle = Tabs.Eggs:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Default = false
})

-- Utility function to check if egg is inside RotatingEggs
local function isRotatingEgg(eggName)
    local rotatingEggs = workspace:FindFirstChild("GameObjects") and workspace.GameObjects:FindFirstChild("RotatingEggs")
    if not rotatingEggs then return false end
    return rotatingEggs:FindFirstChild(eggName) ~= nil
end

AutoHatchToggle:OnChanged(function()
    if AutoHatchToggle.Value then
        spawn(function()
            while AutoHatchToggle.Value do
                local selectedEgg = EggDropdown.Value
                local hatchMultiplier = HatchAmountDropdown.Value

                local args = {}

                local rotating = isRotatingEgg(selectedEgg)

                if rotating then
                    -- Use 7th arg = true for rotating eggs (like 2x luck eggs)
                    if hatchMultiplier == "1x" then
                        args = {selectedEgg, nil, nil, false, nil, nil, true}
                    elseif hatchMultiplier == "3x" then
                        args = {selectedEgg, nil, true, false, nil, nil, true}
                    elseif hatchMultiplier == "8x" then
                        args = {selectedEgg, nil, false, true, true, nil, true}
                    elseif hatchMultiplier == "30x" then
                        args = {selectedEgg, nil, nil, false, nil, true, true}
                    elseif hatchMultiplier == "Max" then
                        args = {selectedEgg, nil, nil, false, nil, true, true}
                    end
                else
                    -- Normal hatch without 7th arg for other eggs
                    if hatchMultiplier == "1x" then
                        args = {selectedEgg, nil, nil, false, nil}
                    elseif hatchMultiplier == "3x" then
                        args = {selectedEgg, nil, true, false}
                    elseif hatchMultiplier == "8x" then
                        args = {selectedEgg, nil, false, true, true}
                    elseif hatchMultiplier == "30x" then
                        args = {selectedEgg, nil, nil, false, nil, true}
                    elseif hatchMultiplier == "Max" then
                        args = {selectedEgg, nil, nil, false, nil, true}
                    end
                end

                -- Invoke server call to hatch egg
                game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))

                wait(0.1)
            end
        end)
    end
end)

local EggStatusParagraph = Tabs.Eggs:Paragraph("EggInfo", {
    Title = "Note",
    Content = "If the egg selected has a 2x luck version, it will hatch that, and return to normal after.",
    ContentAlignment = Enum.TextXAlignment.Left
})

local WheelSection = Tabs.Wheel:AddSection("Pirate Wheel")

local GhostFortuneSpinDropdown = Tabs.Wheel:AddDropdown("GhostFortuneSpinAmount", {
    Title = "Spin Amount",
    Description = "Select Wheel Spin Amount",
    Values = {"1x", "3x", "10x"},
    Multi = false,
    Default = "1x"
})

local AutoGhostFortuneToggle = Tabs.Wheel:AddToggle("AutoGhostFortuneSpin", {
    Title = "Auto spin pirate wheel",
    Default = false
})

AutoGhostFortuneToggle:OnChanged(function()
    if AutoGhostFortuneToggle.Value then
        spawn(function()
            while true do
                if not AutoGhostFortuneToggle.Value then break end
                
                local args = {
                    [1] = "Pirate Fortune",
                    [2] = GhostFortuneSpinDropdown.Value == "3x" and "x10" or GhostFortuneSpinDropdown.Value == "10x" and "x25" or nil
                }
                game:GetService("ReplicatedStorage").Packages.Knit.Services.SpinnerService.RF.Spin:InvokeServer(unpack(args))
                
                wait(1)
            end
        end)
    end
end)


-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Packages.Knit)

-- Player
local player = Players.LocalPlayer

-- Get all possible items from LimitedMerchant module (Pirate Merchant only)
local function getAllItems()
    local LimitedMerchant = require(ReplicatedStorage.Data.LimitedMerchant)
    local allItems = {}
    local slotItemMap = {} -- Track items by slot and title to avoid duplicates
    
    local merchantName = "Pirate Merchant"
    local merchantData = LimitedMerchant[merchantName]
    
    if merchantData and merchantData.Items then
        for slotIndex, itemList in pairs(merchantData.Items) do
            for itemIndex, item in ipairs(itemList) do
                local title = item.Title or "Unknown"
                local key = merchantName .. ":" .. slotIndex .. ":" .. title
                
                -- Only add if this exact item in this slot hasn't been added yet
                if not slotItemMap[key] then
                    local itemName = string.format("%s - %s (Slot %s) (%.0f %s)",
                        title,
                        merchantName,
                        slotIndex,
                        item.Price or 0,
                        typeof(item.Currency) == "string" and item.Currency or (typeof(item.Currency) == "table" and item.Currency.Item or "Unknown Currency")
                    )
                    
                    table.insert(allItems, {
                        name = itemName,
                        merchant = merchantName,
                        slot = tonumber(slotIndex),
                        index = itemIndex,
                        raw = item
                    })
                    
                    slotItemMap[key] = true
                end
            end
        end
    end

    return allItems
end

-- Get live replica data (used to check if item is currently in merchant and has stock)
local function getLiveStockData()
    local ReplicaController = require(ReplicatedStorage.ReplicaController)
    ReplicaController.RequestData()

    local startTime = tick()
    local replica
    repeat
        task.wait(0.1)
        local CustomReplicaController = Knit.GetController("CustomReplicaController")
        replica = CustomReplicaController and CustomReplicaController:GetReplica()
    until replica or tick() - startTime > 5

    local liveData = {}
    
    if replica and replica.Data and replica.Data.LimitedMerchant then
        -- Only get data for Pirate Merchant
        local merchantName = "Pirate Merchant"
        local merchantData = replica.Data.LimitedMerchant[merchantName]
        
        if merchantData and merchantData.Items then
            for slotIndex, itemData in pairs(merchantData.Items) do
                -- Get the actual item details from the LimitedMerchant module
                local LimitedMerchant = require(ReplicatedStorage.Data.LimitedMerchant)
                local currentItem = LimitedMerchant[merchantName].Items[slotIndex][itemData.Index]
                
                -- Store more detailed information including the title for easier matching
                liveData[merchantName .. ":" .. slotIndex] = {
                    stock = itemData.Stock,
                    index = itemData.Index,
                    title = currentItem and currentItem.Title or "Unknown",
                    fullItem = currentItem
                }
            end
        end
    end

    return liveData
end

-- UI Section
local MerchantSection = Tabs.Merchant:AddSection("Pirate Merchant")

-- Get all items list and build name list + map
local allItemDataList = getAllItems()
local allItemNames = {}
local allItemDataMap = {}

for _, itemInfo in ipairs(allItemDataList) do
    table.insert(allItemNames, itemInfo.name)
    allItemDataMap[itemInfo.name] = itemInfo
end

table.sort(allItemNames)

-- Dropdown UI (before toggle)
local MerchantDropdown = MerchantSection:AddDropdown("MerchantSelect", {
    Title = "Select Pirate Merchant Item(s)",
    Description = "Choose items to auto-buy from Pirate Merchant.",
    Values = allItemNames,
    Multi = true,
    Searchable = true,
    Default = {}
})

-- Variables to hold selected items
local selectedMerchantItems = {}

-- Toggle for Auto Buying (below dropdown)
local AutoBuyToggle = MerchantSection:AddToggle("AutoBuy", {
    Title = "Auto Buy Pirate Items",
    Default = false
})

-- Paragraph to show selected items BELOW the toggle
local SelectedItemsParagraph = MerchantSection:Paragraph("SelectedItemsDisplay", {
    Title = "Selected Pirate Items",
    Content = "None selected",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Status paragraph to show recent activity
local StatusParagraph = MerchantSection:Paragraph("StatusDisplay", {
    Title = "Status",
    Content = "Waiting to start...",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Dropdown selection changed handler
MerchantDropdown:OnChanged(function(value)
    selectedMerchantItems = value

    local selectedList = {}
    for itemName, isSelected in pairs(value) do
        if isSelected then
            table.insert(selectedList, itemName)
        end
    end

    if #selectedList > 0 then
        SelectedItemsParagraph:SetValue(table.concat(selectedList, "\n"))
    else
        SelectedItemsParagraph:SetValue("None selected")
    end
end)

-- Auto Buy Loop
AutoBuyToggle:OnChanged(function(enabled)
    if enabled then
        StatusParagraph:SetValue("Starting auto-buy loop...")
        
        task.spawn(function()
            while AutoBuyToggle.Value do
                local liveData = getLiveStockData()
                local purchasesMade = false
                
                -- Check for each selected item
                for itemName, isSelected in pairs(selectedMerchantItems) do
                    if isSelected then
                        local info = allItemDataMap[itemName]
                        
                        if info then
                            local merchantName = info.merchant
                            local slot = info.slot
                            local merchantSlotKey = merchantName .. ":" .. tostring(slot)
                            local liveInfo = liveData[merchantSlotKey]
                            
                            -- Check if this slot has an item with stock
                            if liveInfo and liveInfo.stock and liveInfo.stock > 0 then
                                -- Check if the current item in this slot is the one we want to buy
                                -- Compare titles for safer matching
                                local itemTitle = info.raw.Title
                                if itemTitle == liveInfo.title then
                                    StatusParagraph:SetValue("Found selected item: " .. itemTitle .. "\nAttempting purchase...")
                                    
                                    local success, result = pcall(function()
                                        return ReplicatedStorage.Packages.Knit.Services.LimitedMerchantService.RF.BuyItem:InvokeServer(merchantName, slot)
                                    end)
                                    
                                    if success then
                                        StatusParagraph:SetValue("Successfully purchased: " .. itemTitle)
                                        purchasesMade = true
                                    else
                                        StatusParagraph:SetValue("Failed to purchase: " .. itemTitle .. "\nError: " .. tostring(result))
                                    end
                                    
                                    -- Short delay after purchasing
                                    task.wait(0.5)
                                end
                            end
                        end
                    end
                end
                
                if not purchasesMade then
                    StatusParagraph:SetValue("Checking for selected items...\nLast check: " .. os.date("%X"))
                end
                
                -- Wait before next check cycle
                task.wait(1.5)
            end
            
            StatusParagraph:SetValue("Auto-buy stopped.")
        end)
    else
        StatusParagraph:SetValue("Auto-buy disabled.")
    end
end)


-- Create fishing section in the Fish tab
local FishSection = Tabs.Fish:AddSection("Auto Fish")

-- Create toggle for auto fishing with anchoring
local AutoFishToggle = Tabs.Fish:AddToggle("AutoFish", {
    Title = "Auto Fish",
    Description = "Automatically catch fish with a 100% success chance."
})

-- Create status paragraph to track fishing status
local FishingStatusParagraph = Tabs.Fish:Paragraph("FishingStatus", {
    Title = "Fishing Status",
    Content = "Toggle on to start fishing",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local FishingNote = Tabs.Fish:Paragraph("FishingNote", {
    Title = "Note",
    Content = "You need to be in the water for this to work. This will break if auto fight/train is enabled.",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Variables for fishing
local autoFishingActive = false
local currentFishingState = "idle"
local reelingConnection = nil
local fishStats = {
    totalCaught = 0,
    startTime = 0,
}

-- Store original fishing controller functions
local originalUpdateReeling = nil
local originalUpdateFishPosition = nil
local originalFishingEnd = nil

-- Function to update the status paragraph
local function updateFishingStatus()
    local timeElapsed = os.time() - fishStats.startTime
    local statusText = "State: " .. currentFishingState:gsub("^%l", string.upper)
    statusText = statusText .. "\nCaught: " .. fishStats.totalCaught
    
    if timeElapsed > 0 and AutoFishToggle.Value then
        local rate = math.floor(fishStats.totalCaught / (timeElapsed / 60) * 10) / 10
        statusText = statusText .. "\nRate: " .. rate .. " fish/min"
        statusText = statusText .. "\nRunning: " .. math.floor(timeElapsed / 60) .. "m " .. timeElapsed % 60 .. "s"
    end

    pcall(function()
        FishingStatusParagraph:SetValue(statusText)
    end)
end

-- Function to simulate input
local function simulateInput(inputType, keyCode, began)
    local fakeInput = {
        UserInputType = inputType or Enum.UserInputType.MouseButton1,
        KeyCode = keyCode or Enum.KeyCode.Unknown
    }
    
    pcall(function()
        local FishingController = require(game:GetService("ReplicatedStorage").Controllers.VSCClient.FishingController)
        if began then
            FishingController.InputBegan(fakeInput, false)
        else
            FishingController.InputEnded(fakeInput, false)
        end
    end)
end

-- Function to hook fishing controller with anchoring
local function hookFishingController()
    local success, FishingController = pcall(function()
        return require(game:GetService("ReplicatedStorage").Controllers.VSCClient.FishingController)
    end)
    
    if not success then return false end
    
    -- Store original functions
    originalUpdateReeling = FishingController.UpdateReeling
    originalUpdateFishPosition = FishingController.UpdateFishPosition
    originalFishingEnd = FishingController.FishingEnd
    
    -- Hook UpdateFishPosition to prevent fish movement when anchored
    FishingController.UpdateFishPosition = function(...)
        if AutoFishToggle.Value and FishingController.Reeling then
            -- Don't update fish position when anchored during reeling
            return
        end
        return originalUpdateFishPosition(...)
    end
    
    -- Hook UpdateReeling with anchoring system
    FishingController.UpdateReeling = function(...)
        if not AutoFishToggle.Value then
            -- Normal behavior when not anchored
            return originalUpdateReeling(...)
        end
        
        -- Custom anchored behavior
        local var23_upvw = FishingController._reelingConnection
        if var23_upvw then
            var23_upvw:Disconnect()
        end
        
        -- Set up anchored reeling loop
        local var26_upvw = 0.65
        local PlayerGui = game.Players.LocalPlayer.PlayerGui
        local FishingBar = PlayerGui.Fishing.Bar
        local Inner = FishingBar.Inner
        local ProgressBar = FishingBar.Progress.Bar
        
        local TweenService = game:GetService("TweenService")
        local CurrentCamera = workspace.CurrentCamera
        
        local BackgroundColor3_upvr_2 = Color3.fromRGB(134, 26, 26)
        local BackgroundColor3_upvr = Color3.fromRGB(255, 56, 56)
        local OriginalInnerColor = Inner.BackgroundColor3
        local OriginalBackgroundColor = Inner.Background.BackgroundColor3
        
        local TweenInfo_new_result1_upvr = TweenInfo.new(0.05, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
        
        var23_upvw = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
            if not AutoFishToggle.Value then
                var23_upvw:Disconnect()
                return
            end
            
            -- Check if we should continue reeling
            if not FishingController.Reeling then
                var23_upvw:Disconnect()
                return
            end
            
            -- Keep inner bar centered and stationary
            Inner.Position = UDim2.fromScale(0.5, Inner.Position.Y.Scale)
            
            -- Since both are centered, they should always overlap
            local isOverlapping = true
            
            -- Update progress based on overlap
            if isOverlapping then
                var26_upvw = var26_upvw + deltaTime / 10
                Inner.BackgroundColor3 = OriginalInnerColor
                Inner.Background.BackgroundColor3 = OriginalBackgroundColor
            else
                var26_upvw = var26_upvw - deltaTime / 10
                Inner.BackgroundColor3 = BackgroundColor3_upvr_2
                Inner.Background.BackgroundColor3 = BackgroundColor3_upvr
            end
            
            -- Clamp progress
            var26_upvw = math.clamp(var26_upvw, 0, 1)
            
            -- Update progress bar
            TweenService:Create(ProgressBar, TweenInfo_new_result1_upvr, {
                Size = UDim2.fromScale(var26_upvw, 1)
            }):Play()
            
            -- Update camera FOV
            TweenService:Create(CurrentCamera, TweenInfo_new_result1_upvr, {
                FieldOfView = 70 + (var26_upvw * 20)
            }):Play()
            
            -- Check for completion
            if var26_upvw >= 1 then
                FishingController.FishingEnd(1) -- Success
            elseif var26_upvw <= 0 then
                FishingController.FishingEnd(0) -- Failure
            end
        end)
        
        -- Store connection for cleanup
        FishingController._reelingConnection = var23_upvw
    end
    
    -- Hook the fishing end function to track catches and restart
    FishingController.FishingEnd = function(result, ...)
        local returnValue = originalFishingEnd(result, ...)
        
        -- Clean up reeling connection
        if FishingController._reelingConnection then
            FishingController._reelingConnection:Disconnect()
            FishingController._reelingConnection = nil
        end
        
        -- Track successful catches
        if result == 1 then
            fishStats.totalCaught = fishStats.totalCaught + 1
        end
        
        currentFishingState = "idle"
        updateFishingStatus()
        
        -- Restart auto fishing after a delay if still enabled
        if AutoFishToggle.Value and autoFishingActive then
            spawn(function()
                wait(0.75) -- Wait exactly 1 second after fishing ends
                if AutoFishToggle.Value and autoFishingActive then
                    autoFishingLoop()
                end
            end)
        end
        
        return returnValue
    end
    
    return true
end

-- Main auto fishing loop
function autoFishingLoop()
    if not AutoFishToggle.Value or autoFishingActive then
        return
    end
    
    autoFishingActive = true
    
    spawn(function()
        while AutoFishToggle.Value and autoFishingActive do
            local character = game.Players.LocalPlayer.Character
            if not character then
                task.wait(1)
                continue
            end
            
            local FishingController = require(game:GetService("ReplicatedStorage").Controllers.VSCClient.FishingController)
            
            -- Check if we have a fishing rod equipped or in backpack
            local hasFishingRod = character:FindFirstChild("FishingRod") or game.Players.LocalPlayer.Backpack:FindFirstChild("FishingRod")
            
            if not hasFishingRod then
                currentFishingState = "no rod"
                updateFishingStatus()
                task.wait(5)
                continue
            end
            
            -- Equip fishing rod if not equipped
            if not character:FindFirstChild("FishingRod") and not FishingController.RodEquipped then
                pcall(function()
                    FishingController.ToggleFishingRod()
                end)
                task.wait(1)
            end
            
            -- Start fishing process
            if not FishingController.Casting and not FishingController.CastingStart and not FishingController.Reeling then
                currentFishingState = "casting"
                updateFishingStatus()
                
                -- Start casting
                simulateInput(Enum.UserInputType.MouseButton1, nil, true)
                task.wait(0.1)
                
                -- Hold for a moment then release to cast
                task.wait(math.random(0.5, 1.5)) -- Random cast power
                simulateInput(Enum.UserInputType.MouseButton1, nil, false)
                
                -- Wait exactly 1 second after cast
                task.wait(1)
                
                currentFishingState = "waiting"
                updateFishingStatus()
            end
            
            -- Wait for reeling to start
            if FishingController.Reeling and currentFishingState ~= "reeling" then
                currentFishingState = "reeling"
                updateFishingStatus()
                -- The anchoring system is now handled by the hooked UpdateReeling function
            end
            
            task.wait(0.5)
        end
        
        autoFishingActive = false
        currentFishingState = "idle"
        updateFishingStatus()
    end)
end

-- Function to stop auto fishing
local function stopAutoFishing()
    autoFishingActive = false
    currentFishingState = "stopped"
    
    -- Clean up any reeling connections
    pcall(function()
        local FishingController = require(game:GetService("ReplicatedStorage").Controllers.VSCClient.FishingController)
        if FishingController._reelingConnection then
            FishingController._reelingConnection:Disconnect()
            FishingController._reelingConnection = nil
        end
    end)
    
    -- Restore original functions
    if originalUpdateReeling and originalUpdateFishPosition and originalFishingEnd then
        pcall(function()
            local FishingController = require(game:GetService("ReplicatedStorage").Controllers.VSCClient.FishingController)
            FishingController.UpdateReeling = originalUpdateReeling
            FishingController.UpdateFishPosition = originalUpdateFishPosition
            FishingController.FishingEnd = originalFishingEnd
        end)
    end
    
    updateFishingStatus()
end

-- Set up toggle callback
AutoFishToggle:OnChanged(function()
    if AutoFishToggle.Value then
        -- Reset statistics
        fishStats.totalCaught = 0
        fishStats.startTime = os.time()
        
        -- Hook fishing controller
        if hookFishingController() then
            currentFishingState = "starting"
            updateFishingStatus()
            
            -- Start auto fishing after a short delay
            spawn(function()
                wait(2)
                if AutoFishToggle.Value then
                    autoFishingLoop()
                end
            end)
        else
            currentFishingState = "error"
            updateFishingStatus()
            AutoFishToggle:Set(false)
        end
    else
        stopAutoFishing()
    end
end)


-- Helper to recursively find a nested table by name
local function findTableByName(tbl, targetName)
    for key, value in pairs(tbl) do
        if key == targetName and typeof(value) == "table" then
            return value
        elseif typeof(value) == "table" then
            local found = findTableByName(value, targetName)
            if found then
                return found
            end
        end
    end
    return nil
end

-- Format SpiritFruits: "FruitName: val1 val2 val3"
local function formatSpiritFruits(tbl)
    local output = "Fossils:\n"
    for fruitName, subTable in pairs(tbl) do
        if typeof(subTable) == "table" then
            local valuesStr = ""
            for _, v in pairs(subTable) do
                if typeof(v) == "number" then
                    v = math.round(v) -- round number
                end
                valuesStr = valuesStr .. tostring(v) .. " "
            end
            output = output .. fruitName .. ": " .. valuesStr .. "\n"
        else
            if typeof(subTable) == "number" then
                subTable = math.round(subTable)
            end
            output = output .. fruitName .. ": " .. tostring(subTable) .. "\n"
        end
    end
    return output
end

-- Format ElementalAlchemist: "Water: xp = 100, level = 2"
local function formatElementalAlchemist(tbl)
    local output = "\n Ancient Awakening :\n"
    for element, data in pairs(tbl) do
        if typeof(data) == "table" then
            local line = {}
            for key, val in pairs(data) do
                if typeof(val) == "number" then
                    val = math.round(val) -- round number
                end
                table.insert(line, key .. " = " .. tostring(val))
            end
            output = output .. element .. ": " .. table.concat(line, ", ") .. "\n"
        else
            if typeof(data) == "number" then
                data = math.round(data)
            end
            output = output .. element .. ": " .. tostring(data) .. "\n"
        end
    end
    return output
end

-- Create combined section and paragraph
local APSection = Tabs.Fossil:AddSection("Fossils + Ancient Awakening Data")
local CombinedParagraph = APSection:Paragraph("SpiritAndElemental", {
    Title = "Your Data",
    Content = "Loading..."
})

-- Update function for both tables
local function updateCombinedData()
    local CustomReplicaController = Knit.GetController("CustomReplicaController")
    local replica = CustomReplicaController and CustomReplicaController:GetReplica()

    if not replica then
        CombinedParagraph:SetValue("Replica not found.")
        return
    end

    local spiritFruits = findTableByName(replica, "SummerItems")
    local elementalData = findTableByName(replica, "AncientAwakening")

    local output = ""

    if spiritFruits then
        output = output .. formatSpiritFruits(spiritFruits)
    else
        output = output .. "SpiritFruits table not found.\n"
    end

    if elementalData then
        output = output .. formatElementalAlchemist(elementalData)
    else
        output = output .. "\nElementalAlchemist table not found."
    end

    CombinedParagraph:SetValue(output)
end

-- Refresh every second
spawn(function()
    while true do
        updateCombinedData()
        wait(1)
    end
end)

-- Initial call
updateCombinedData()


local RunService = game:GetService("RunService")

local APSection = Tabs.Fossil:AddSection("Sacrifice Fossils")

local ElementDropdown = APSection:CreateDropdown("ElementDropdown", {
    Title = "Select Element",
    Description = "Select Spirit Fruit element",
    Values = {"SummerCoins", "SumerBicep", "SummerGrip", "SumerKnuckles"},
    Default = "--"
})

local SpiritFruitDropdown = APSection:CreateDropdown("SpiritFruitDropdown", {
    Title = "Select Spirit Fruit(s)",
    Description = "Select Spirit Fruits to sacrifice",
    Values = {
        "Serpent Fossil",
        "Skull of Oracle Fossil",
        "Frozen Heartstone Fossil",
        "Raptor Claw Fossil",
        "Leviathan Tooth Fossil",
        "Trilobit Shell Fossil",
        "T-Rex Horn Fossil",
        "Phoenix Fossil"
    },

    Multi = true,
    Searchable = true,
    Default = {}
})

local selectamount = APSection:CreateDropdown("SelectAmount", {
    Title = "Select Amount",
    Description = "Select the amount of the the selected fossils to sacrifice. If 1 is selected, it will sacrifice the fossil one at a time, but very quickly.",
    Values = {"1", "All"},
    Default = "--"
})

local AutoSacrificeToggle = APSection:CreateToggle("AutoSacrificeToggle", {
    Title = "Auto Sacrifice",
    Description = "Automatically sacrifice selected fossils."
})

local sacrificeConnection = nil

local function safeGetValue(dropdown)
    if not dropdown then
        warn("Dropdown/Toggler is nil")
        return nil
    end
    return dropdown.Value
end

local function getSelectedElement()
    local element = safeGetValue(ElementDropdown)
    if element == "--" or element == nil then return nil end
    return element
end

local function getSelectedSpiritFruits()
    local selectedFruits = {}
    local values = safeGetValue(SpiritFruitDropdown)
    if type(values) ~= "table" then return {} end
    for fruit, selected in pairs(values) do
        if selected then
            table.insert(selectedFruits, fruit)
        end
    end
    return selectedFruits
end

local function getSelectedAmount()
    local amount = safeGetValue(selectamount)
    if amount == "--" or amount == nil then return nil end
    return amount
end

local function runSacrifice()
    local element = getSelectedElement()
    local fruits = getSelectedSpiritFruits()
    local amount = getSelectedAmount()

    if not element or #fruits == 0 or not amount then
        -- Missing selection, skip
        return
    end

    for _, fruit in ipairs(fruits) do
        local args = {
            [1] = element,
            [2] = fruit,
            [3] = (amount == "1" and "Single") or (amount == "All" and "All") or "Single"
        }
        local success, err = pcall(function()
            game:GetService("ReplicatedStorage").Packages.Knit.Services.ElementAlchemistService.RF.Offer:InvokeServer(unpack(args))
        end)
        if not success then
            warn("Failed to invoke sacrifice for", fruit, err)
        end
    end
end

local function startSacrificeLoop()
    if sacrificeConnection then
        sacrificeConnection:Disconnect()
        sacrificeConnection = nil
    end

    -- Run instantly on toggle ON
    runSacrifice()

    -- Then every 5 seconds
    local accum = 0
    sacrificeConnection = RunService.Heartbeat:Connect(function(step)
        accum = accum + step
        if accum >= 5 then
            accum = 0
            runSacrifice()
        end
    end)
end

local function stopSacrificeLoop()
    if sacrificeConnection then
        sacrificeConnection:Disconnect()
        sacrificeConnection = nil
    end
end

AutoSacrificeToggle:OnChanged(function(value)
    if value then
        startSacrificeLoop()
    else
        stopSacrificeLoop()
    end
end)

selectamount:OnChanged(function()
    if AutoSacrificeToggle.Value then
        -- Restart loop to update timing if needed (optional)
        startSacrificeLoop()
    end
end)

ElementDropdown:OnChanged(function()
    if AutoSacrificeToggle.Value then
        startSacrificeLoop()
    end
end)

SpiritFruitDropdown:OnChanged(function()
    if AutoSacrificeToggle.Value then
        startSacrificeLoop()
    end
end)

-- If toggle already on at script start, begin the loop
if AutoSacrificeToggle.Value then
    startSacrificeLoop()
end

local section = Tabs.Quest:AddSection("Pirate Quest")


section:AddButton({
    Title = "Complete the pirate quest",
    Description = "Instantly complete the pirate quest.",
    Callback = function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

        -- Utility: teleport player in front of a part
        local function teleportTo(part)
            if part and Character then
                Character:PivotTo(part:GetPivot() * CFrame.new(0, 0, -5))
            end
        end

        -- Utility: safely fire a prompt
        local function tryFirePrompt(target)
            if target then
                local prompt = target:FindFirstChildWhichIsA("ProximityPrompt", true)
                if prompt then
                    teleportTo(target)
                    task.wait(0.25)
                    fireproximityprompt(prompt, Character:FindFirstChild("Humanoid"))
                    return true
                end
            end
            return false
        end

        local function getQuestRoot()
            return workspace:FindFirstChild("Zones")
                and workspace.Zones:FindFirstChild("SummerIsland")
                and workspace.Zones.SummerIsland:FindFirstChild("Interactables")
                and workspace.Zones.SummerIsland.Interactables:FindFirstChild("Quest")
        end

        -- Step 1: Talk to the LostPirate NPC (start quest)
        local questRoot = getQuestRoot()
        local lostPirate = questRoot and questRoot:FindFirstChild("LostPirate")
        if tryFirePrompt(lostPirate) then
            print("Started Pirate Quest")
        end

        -- Step 2: Collect 10 GoldenPlanks
        for i = 1, 10 do
            local plank = questRoot
                and questRoot:FindFirstChild("LostPirateItems")
                and questRoot.LostPirateItems:FindFirstChild("GoldenPlank" .. i)
            if plank and plank:FindFirstChild("Hitbox") then
                if tryFirePrompt(plank.Hitbox) then
                    print("Collected GoldenPlank" .. i)
                end
            end
            task.wait(0.3)
        end

        -- Step 3: Return to LostPirate to complete
        if tryFirePrompt(lostPirate) then
            print("Completed Pirate Quest")
        end
    end
})





-- Hand the library over to our managers
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes{}

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab("Settings")

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()

