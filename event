-- Function to get all valid egg names in alphabetical order, excluding "Egg Rewind"
local function getEggNames()
    local eggNamesSet = {} -- Use a set to prevent duplicates
    local zones = workspace:FindFirstChild("Zones")

    if zones then
        for _, zone in pairs(zones:GetChildren()) do
            if zone:IsA("Folder") and not zone.Name:match("%d") and not zone.Name:match("Brainrot") and not zone.Name:match("Forest") and not zone.Name:match("Lake") and not zone.Name:match("Beach") then -- Ignore zones with numbers
                local interactables = zone:FindFirstChild("Deco") or zone:FindFirstChild("Interactables")
                if interactables then
                    local eggs = interactables:FindFirstChild("Eggs")
                    if eggs then
                        for _, egg in pairs(eggs:GetChildren()) do
                            if not egg.Name:lower():find("rewind") then
                                local name = egg.Name
                                name = name:gsub("%s*[Ee][Gg][Gg]%s*$", "") -- Remove 'egg' at end, case-insensitive
                                name = name:match("^%s*(.-)%s*$") -- Trim leading/trailing whitespace
                                eggNamesSet[name] = true
                            end
                        end
                    end
                end
            end
        end
    end

    -- Convert set to list and sort
    local eggNames = {}
    for name in pairs(eggNamesSet) do
        table.insert(eggNames, name)
    end

    table.sort(eggNames)
    return eggNames
end



loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()
local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()


local Window = Library:Window{
    Title = "Mining Event",
    SubTitle = "By Duckie",
    TabWidth = 160,
    Size =  UDim2.fromOffset(580, 460),
    Resize = false, 
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}


local Tabs = {
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
    AutoFight = Window:AddTab({ Title = "Main", Icon = "crown" }),
    Eggs = Window:AddTab({ Title = "Eggs", Icon = "egg" }),
    Tower = Window:AddTab({ Title = "Tower", Icon = "castle" }),
    Merchant = Window:AddTab({ Title = "Merchant", Icon = "phosphor-shopping-cart-fill" }),
    Mining = Window:AddTab({ Title = "Mining", Icon = "pickaxe" }),
}



local PlaytimeSection = Tabs.AutoFight:AddSection("Playtime Pass")

local AutoPlaytimeToggle = PlaytimeSection:AddToggle("AutoPlaytime", {
    Title = "Auto Claim Playtime Pass",
    Default = false
})

AutoPlaytimeToggle:OnChanged(function()
    if AutoPlaytimeToggle.Value then
        -- Claim rewards immediately when enabled
        for i = 1, 12 do
            local args = {
                [1] = "Free",
                [2] = i
            }
            game:GetService("ReplicatedStorage").Packages.Knit.Services.EventPassService.RF.ClaimReward:InvokeServer(unpack(args))
        end
        
        -- Start reset/claim loop
        spawn(function()
            while AutoPlaytimeToggle.Value do
                wait(60) -- Wait before reset
                
                -- Reset pass
                game:GetService("ReplicatedStorage").Packages.Knit.Services.EventPassService.RF.Reset:InvokeServer()
                
                -- Claim all rewards after reset
                for i = 1, 12 do
                    local args = {
                        [1] = "Free",
                        [2] = i
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.EventPassService.RF.ClaimReward:InvokeServer(unpack(args))
                end
            end
        end)
    end
end)

local function GetCurrentZone()
    local player = game.Players.LocalPlayer
    if player:GetAttribute("ZoneMinersDreamland") then
        return "MinersDreamland"
    end
    
    -- Look through workspace as fallback

    local frontmanZone = workspace.Zones:FindFirstChild("MinersDreamland")
    if frontmanZone then return frontmanZone.Name end

    local glassBridgeZone = workspace.Zones:FindFirstChild("MinersDreamland")
    if glassBridgeZone then return glassBridgeZone.Name end
    
    
    return nil
end

local function GetValidZone(trainingType)
    local zone = GetCurrentZone()
    local fallback = "MinersDreamland"
    local replicatedStorage = game:GetService("ReplicatedStorage")

    local function hasData(moduleName)
        local success, module = pcall(function()
            return require(replicatedStorage.Data[moduleName])
        end)
        return success and module and (module[zone] or module[fallback])
    end

    if trainingType == "PunchBags" then
        if workspace.Zones:FindFirstChild(zone)
            and workspace.Zones[zone]:FindFirstChild("Interactables")
            and workspace.Zones[zone].Interactables:FindFirstChild("Training")
            and workspace.Zones[zone].Interactables.Training:FindFirstChild("PunchBags") then
            return zone
        elseif workspace.Zones:FindFirstChild(fallback)
            and workspace.Zones[fallback]:FindFirstChild("Interactables")
            and workspace.Zones[fallback].Interactables:FindFirstChild("Training")
            and workspace.Zones[fallback].Interactables.Training:FindFirstChild("PunchBags") then
            return fallback
        else
            return fallback
        end
    elseif trainingType == "Dumbells" then
        return hasData("Dumbells") and (hasData("Dumbells")[zone] and zone or fallback) or fallback
    elseif trainingType == "Grips" then
        return hasData("Grips") and (hasData("Grips")[zone] and zone or fallback) or fallback
    elseif trainingType == "Barbells" then
        return hasData("Barbells") and (hasData("Barbells")[zone] and zone or fallback) or fallback
    end

    return fallback
end


local function GetBestDuckBag()
    local player = game.Players.LocalPlayer
    local currentZone = GetValidZone(currentTrainingType)
    local fallbackZone = "MinersDreamland"

    if not currentZone then
        return "Tier1"
    end

    local knuckleStrength = player:GetAttribute("TotalBrainrotKnuckles") or 0
    local punchBagData = require(game:GetService("ReplicatedStorage").Data.PunchBags)

    if player:GetAttribute("VIP") == true then
        return "VIP"
    end

    local zoneList = { currentZone, fallbackZone }

    for _, zone in ipairs(zoneList) do
        local bestTier = "Tier1"
        local highestRequired = 0

        if punchBagData and punchBagData[zone] then
            for tier, data in pairs(punchBagData[zone]) do
                if data.StrengthRequired and
                   knuckleStrength >= data.StrengthRequired and
                   data.StrengthRequired > highestRequired then
                    bestTier = tier
                    highestRequired = data.StrengthRequired
                end
            end
            -- Return best tier found in this zone
            return bestTier
        end
    end
end


local function GetBestDuckEquipment(equipmentType)
    local player = game.Players.LocalPlayer
    local currentZone = GetCurrentZone()
    local fallbackZone = "MinersDreamland"

    if not currentZone then
        return { equipment = fallbackZone .. "1", zone = fallbackZone }
    end

    -- Determine attribute and data module based on type
    local dataModule
    local attrMap = {
        Dumbells = "TotalMiningBicep",
        Grips = "TotalMiningGrip",
        Barbells = "TotalMiningBicep"
    }

    if equipmentType ~= "Dumbells" and equipmentType ~= "Grips" and equipmentType ~= "Barbells" then
        equipmentType = "Dumbells"
    end

    dataModule = equipmentType
    local equipmentData

    pcall(function()
        equipmentData = require(game:GetService("ReplicatedStorage").Data[dataModule])
    end)

    if not equipmentData then
        return { equipment = fallbackZone .. "1", zone = fallbackZone }
    end

    -- Zone priority list
    local zoneList = { currentZone, fallbackZone }

    for _, zone in ipairs(zoneList) do
        local defaultEquipment = zone .. "1"
        local bestEquipment = defaultEquipment
        local highestRequired = 0

        -- Use the correct attribute for fallback zone too
        local statValue = player:GetAttribute(attrMap[equipmentType]) or 0

        if equipmentData[zone] then
            for name, data in pairs(equipmentData[zone]) do
                if data.StrengthRequired and 
                   statValue >= data.StrengthRequired and 
                   data.StrengthRequired > highestRequired then
                    bestEquipment = name
                    highestRequired = data.StrengthRequired
                end
            end
            return { equipment = bestEquipment, zone = zone }
        end
    end

    return { equipment = fallbackZone .. "1", zone = fallbackZone }
end

    

-- Add Training Section
local TrainSection = Tabs.AutoFight:AddSection("Auto Train")

local TrainingDropdown = Tabs.AutoFight:AddDropdown("TrainingSelect", {
    Title = "Select Training Type",
    Values = {"Dumbells", "PunchBags", "Grips", "Barbells"}, 
    Multi = false,
    Default = "Dumbells"
})

local AutoTrainToggle = Tabs.AutoFight:AddToggle("AutoTrain", {
    Title = "Auto Train",
    Description = "If this gets an error, turn the toggle off and on again. It occurs when you switch training types with the toggle on :)",
    Default = false
})

-- Variable to store the current training equipment type
local currentTrainingType = nil

AutoTrainToggle:OnChanged(function()
    if AutoTrainToggle.Value then
        -- Store the selected training type when starting
        currentTrainingType = TrainingDropdown.Value
        
        spawn(function()
            local currentZone = GetCurrentZone()
            
            if not currentZone then
                return
            end
            
            if currentTrainingType == "Dumbells" then
                -- Function to equip Dumbells
                local function equipDumbells()
                    local result = GetBestDuckEquipment("Dumbells")
                    local equipment = result.equipment
                    local equipZone = result.zone
                    local args = {
                        [1] = equipZone,
                        [2] = "Dumbells", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipDumbells()

                -- Click loop (every 0.6 seconds for Dumbells)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.6)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Dumbells" and TrainingDropdown.Value == "Dumbells" then
                        equipDumbells()
                    end
                end
                
            elseif currentTrainingType == "Grips" then
                -- Function to equip Grips
                local function equipGrips()
                    local result = GetBestDuckEquipment("Grips")
                    local equipment = result.equipment
                    local equipZone = result.zone
                    local args = {
                        [1] = equipZone,
                        [2] = "Grips", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipGrips()

                -- Click loop (every 0.6 seconds for Grips)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(0.6)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Grips" and TrainingDropdown.Value == "Grips" then
                        equipGrips()
                    end
                end
                
            elseif currentTrainingType == "Barbells" then
                -- Function to equip Barbells
                local function equipBarbells()
                    local result = GetBestDuckEquipment("Barbells")
                    local equipment = result.equipment
                    local equipZone = result.zone
                    local args = {
                        [1] = equipZone,
                        [2] = "Barbells", 
                        [3] = equipment
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onGuiEquipRequest:FireServer(unpack(args))
                end

                -- Equip immediately
                equipBarbells()

                -- Click loop (every 1.55 seconds for Barbells)
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" do
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ToolService.RE.onClick:FireServer()
                        wait(1.55)
                    end
                end)

                -- Re-equip loop (every 5 seconds)
                while AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" do
                    wait(5) -- Wait 5 seconds before re-equipping
                    if AutoTrainToggle.Value and currentTrainingType == "Barbells" and TrainingDropdown.Value == "Barbells" then
                        equipBarbells()
                    end
                end
            elseif currentTrainingType == "Pull up bar" then
                -- Add Pull up bar handling
                spawn(function()
                    while AutoTrainToggle.Value and currentTrainingType == "Pull up bar" and TrainingDropdown.Value == "Pull up bar" do
                        local statsArgs = {
                            [1] = "17",
                            [2] = "Tier4"
                        }
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.PullupBarService.RE.onGiveStats:FireServer(unpack(statsArgs))
                        wait(1.55) -- Pull up bar every 1.55 seconds
                    end
                end)
            else -- PunchBags
                spawn(function() 
                    local lastTeleport = 0
                    while AutoTrainToggle.Value and currentTrainingType == "PunchBags" and TrainingDropdown.Value == "PunchBags" do
                        local tier = GetBestDuckBag()
                        local validZone = GetValidZone("PunchBags")
                        
                        -- Try to get the bag from workspace using the valid zone
                        local bag = workspace.Zones[validZone].Interactables.Training.PunchBags:FindFirstChild(tier)
                        
                        if bag then
                            -- Only teleport every 5 seconds
                            local currentTime = tick()
                            if currentTime - lastTeleport >= 5 then
                                local bagCFrame = bag:GetPivot()
                                game.Players.LocalPlayer.Character:PivotTo(bagCFrame * CFrame.new(0, 0, -5))
                                lastTeleport = currentTime
                            end
                            
                            -- Use the punch bag service every 0.2 seconds for knuckles (punch bags)
                            local args = {
                                [1] = validZone,
                                [2] = tier,
                                [3] = game.Players.LocalPlayer:GetAttribute("VIP") == true
                            }
                            game:GetService("ReplicatedStorage").Packages.Knit.Services.PunchBagService.RE.onGiveStats:FireServer(unpack(args))
                        end
                        wait(0.2)
                    end
                end)
            end
        end)
    else
        -- Clear the current training type when stopping
        currentTrainingType = nil
    end
end)

TrainingDropdown:OnChanged(function()
    if AutoTrainToggle.Value then
        AutoTrainToggle:SetValue(false) -- Turn off current training
        wait(0.1) -- Short delay to ensure loops are terminated
        AutoTrainToggle:SetValue(true) -- Turn on with new selection
    end
end)


-- UI section
local FightSection = Tabs.AutoFight:AddSection("Auto Fight")

local npcLocations = {
    MinersDreamland = workspace.GameObjects.ArmWrestling.MinersDreamland.NPC,
}

local modelNames = {}

-- Gather NPC names from all locations
for _, path in pairs(npcLocations) do
    for _, npc in pairs(path:GetChildren()) do
        if npc:IsA("Model") then
            table.insert(modelNames, npc.Name)
        end
    end
end

table.sort(modelNames)

-- Dropdown
local modelDropdown = Tabs.AutoFight:AddDropdown("ModelDropdown", {
    Title = "Select Boss",
    Values = modelNames,
    Multi = false,
    Searchable = true,
    Default = modelNames[1] or "",
})

-- Auto Click toggle
local AutoClickToggle = Tabs.AutoFight:AddToggle("AutoClick", {
    Title = "Auto Click/Crit",
    Description = "Allows you to win fights over 5x as fast.",
    Default = false
})

-- Auto Fight toggle
local AutoFightToggle = Tabs.AutoFight:AddToggle("AutoFight", {
    Title = "Auto Fight",
    Description = "Automatically starts fights with the selected boss (to beat bosses much faster, enable the Auto Click/Crit toggle).",
    Default = false
})

-- Block the GameAnalyticsError remote event from firing (run once at startup)
pcall(function()
    local gameAnalyticsError = game:GetService("ReplicatedStorage"):FindFirstChild("GameAnalyticsError")
    if gameAnalyticsError then
        gameAnalyticsError.FireServer = function(self, ...)
            return
        end
    end
end)


local AlwaysWin = Tabs.AutoFight:AddButton({
    Title = "Always Win",
    Description = "This makes it impossible to lose, rejoining resets this.",
    Callback = function()
        coroutine.resume(coroutine.create(function()
            local armWrestle = require(game:GetService("ReplicatedStorage").Controllers.Fighting.ArmWrestleController)
            
            -- Method 1: Hook the IncrementPower function
            local originalIncrementPower = armWrestle.IncrementPower
            armWrestle.IncrementPower = function(self, amount)
                -- Always increment by a large positive amount
                originalIncrementPower(self, math.abs(amount or 1) * 1000)
            end
            
            -- Method 2: Continuously set health to max (more reliable)
            spawn(function()
                while armWrestle.Fighting do
                    if armWrestle.Health and armWrestle.MaxHealth then
                        armWrestle.Health = armWrestle.MaxHealth
                    end
                    wait(0.1)
                end
            end)
            
            -- Method 3: Override the UpdateFight function to prevent NPC power
            local originalUpdateFight = armWrestle.UpdateFight
            armWrestle.UpdateFight = function(self)
                -- Do nothing - prevents NPC from gaining power
            end
            
        end))
    end
})



local notefight = Tabs.AutoFight:Paragraph("Note", {
    Title = "Note",
    Content = "If you get an error when you turn the toggles on, try turning them off and on again, this wont effect anything. Furthermore, the speeds in which you win, is further increased if you launch the script twice (Open it enable the toggles, disable them, and then re-execute the script.) ",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Services
local KnitServices = game:GetService("ReplicatedStorage").Packages.Knit.Services
local ArmwrestleServiceRF = KnitServices:WaitForChild("ArmWrestleService"):WaitForChild("RF")
local ZoneService = KnitServices:WaitForChild("ZoneService"):WaitForChild("RE")

-- Variables
local autoClickThreads = {}
local autoFightThreads = {}
local cleanupConnections = {}
local lastZoneCheck = 0

-- Function to teleport to the correct zone for an NPC
local function teleportToNpcZone(npcName)
    local player = game.Players.LocalPlayer
    local playerCurrentZone = player:GetAttribute("CurrentZone")
    
    -- Find which zone the NPC is in
    local npcZone = nil
    for zoneName, path in pairs(npcLocations) do
        if path:FindFirstChild(npcName) then
            npcZone = zoneName == "MinersDreamland" and "MinersDreamland" or zoneName
            break
        end
    end
    
    -- If NPC zone found and different from current zone, teleport
    if npcZone and playerCurrentZone ~= npcZone then
        -- Get the teleport destination
        local teleportDest = workspace.Zones[npcZone].Interactables.Teleports.Locations.Spawn
        
        if teleportDest then
            -- Teleport to the appropriate zone
            local args = {
                [1] = teleportDest
            }
            
            ZoneService.teleport:FireServer(unpack(args))
            
            -- Wait for teleport to complete
            task.wait(2.5)

            return true
        end
    end
    return npcZone ~= nil
end

-- Cleanup function to clear pending requests
local function cleanupRequests()
    -- Get memory info before cleanup
    local memoryBefore = gcinfo()
    
    -- Force garbage collection to clear pending requests
    collectgarbage("count")
    
    -- Get memory info after cleanup
    local memoryAfter = gcinfo()
    
    pcall(function()
        -- Clear any pending remote calls by briefly disconnecting
        local temp = ArmwrestleServiceRF
        task.wait(0.01)
    end)
end

-- Auto Click toggle handler
AutoClickToggle:OnChanged(function()
    if AutoClickToggle.Value then
        -- Stop existing threads and cleanup
        for _, thread in pairs(autoClickThreads) do
            if typeof(thread) == "thread" then
                task.cancel(thread)
            elseif typeof(thread) == "table" then
                thread.active = false
            end
        end
        autoClickThreads = {}
        
        -- Stop any existing cleanup connections
        if cleanupConnections.autoClick then
            cleanupConnections.autoClick:Disconnect()
        end
        
        -- Spawn new click threads
        task.spawn(function()
            for i = 1, 500 do
                local threadData = { active = true }
                table.insert(autoClickThreads, threadData)
                
                task.spawn(function()
                    while threadData.active and AutoClickToggle.Value do
                        pcall(function()
                            ArmwrestleServiceRF:WaitForChild("RequestClick"):InvokeServer()
                            ArmwrestleServiceRF:WaitForChild("RequestCritHit"):InvokeServer()
                        end)
                        task.wait()
                    end
                end)
                
                task.wait(0.001) -- Small delay between thread spawns to prevent all spawning at once
            end
        end)
        
        -- Start cleanup timer for auto click
        cleanupConnections.autoClick = task.spawn(function()
            while AutoClickToggle.Value do
                task.wait(5) -- Wait 5 seconds
                if AutoClickToggle.Value then
                    cleanupRequests()
                end
            end
        end)
    else
        -- Disable all click threads
        for _, thread in pairs(autoClickThreads) do
            if typeof(thread) == "thread" then
                task.cancel(thread)
            elseif typeof(thread) == "table" then
                thread.active = false
            end
        end
        autoClickThreads = {}
        
        -- Stop cleanup timer
        if cleanupConnections.autoClick then
            task.cancel(cleanupConnections.autoClick)
            cleanupConnections.autoClick = nil
        end
        
        -- Final cleanup
        cleanupRequests()
    end
end)

-- Auto Fight toggle handler
AutoFightToggle:OnChanged(function()
    if AutoFightToggle.Value then
        -- First try to teleport to correct zone if needed
        local selectedName = modelDropdown.Value
        teleportToNpcZone(selectedName)
        
        -- Stop previous threads and cleanup
        for _, flag in pairs(autoFightThreads) do
            flag.active = false
        end
        autoFightThreads = {}
        
        -- Stop any existing cleanup connections
        if cleanupConnections.autoFight then
            cleanupConnections.autoFight:Disconnect()
        end
        
        -- Spawn threads for repeated boss fights
        for i = 1, 500 do
            local threadFlag = { active = true }
            table.insert(autoFightThreads, threadFlag)
            
            task.spawn(function()
                while threadFlag.active and AutoFightToggle.Value do
                    local selectedName = modelDropdown.Value
                    if selectedName then
                        -- Check if we need to teleport (periodically)
                        local currentTime = tick()
                        if currentTime - lastZoneCheck > 10 then
                            teleportToNpcZone(selectedName)
                            lastZoneCheck = currentTime
                        end
                        
                        -- Request fight with selected NPC
                        local args = {
                            [1] = selectedName
                        }
                        
                        pcall(function()
                            ArmwrestleServiceRF:WaitForChild("RequestStartFight"):InvokeServer(unpack(args))
                        end)
                    end
                    task.wait(0.01)
                end
            end)
            
            task.wait(0.001) -- Small delay between thread spawns
        end
        
        -- Start cleanup timer for auto fight
        cleanupConnections.autoFight = task.spawn(function()
            while AutoFightToggle.Value do
                task.wait(5) -- Wait 5 seconds
                if AutoFightToggle.Value then
                    cleanupRequests()
                end
            end
        end)
    else
        -- Stop all fight threads
        for _, flag in pairs(autoFightThreads) do
            flag.active = false
        end
        autoFightThreads = {}
        
        -- Stop cleanup timer
        if cleanupConnections.autoFight then
            task.cancel(cleanupConnections.autoFight)
            cleanupConnections.autoFight = nil
        end
        
        -- Final cleanup
        cleanupRequests()
    end
end)

-- Add zone check when dropdown selection changes
modelDropdown:OnChanged(function()
    if AutoFightToggle.Value then
        local selectedName = modelDropdown.Value
        teleportToNpcZone(selectedName)
        lastZoneCheck = tick()
    end
end)

local function aggressiveCleanup()
    -- Get memory info before cleanup
    local memoryBefore = gcinfo()
    
    -- Method 1: Force disconnect and reconnect to service
    pcall(function()
        local oldService = ArmwrestleServiceRF
        ArmwrestleServiceRF = KnitServices:WaitForChild("ArmWrestleService"):WaitForChild("RF")
    end)
    
    -- Method 2: Clear all pending coroutines
    collectgarbage("count")
    
    -- Method 3: Brief pause to let network catch up
    task.wait(0.1)
    
    -- Get memory info after cleanup
    local memoryAfter = gcinfo()  
end

local EggSection = Tabs.Eggs:AddSection("Eggs")

-- Hatch Amount Dropdown
local HatchAmountDropdown = Tabs.Eggs:AddDropdown("HatchAmount", {
    Title = "Hatch Amount",
    Values = {"1x", "3x", "8x", "30x", "Max"},
    Multi = false,
    Default = "1x"
})

-- Egg Selection Dropdown (Populated Dynamically)
local eggNames = getEggNames()
local EggDropdown = Tabs.Eggs:AddDropdown("EggSelect", {
    Title = "Select Egg",
    Values = eggNames,
    Multi = false,
    Default = eggNames[1] or "None"
})

-- Auto Hatch Toggle
local AutoHatchToggle = Tabs.Eggs:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Default = false
})

AutoHatchToggle:OnChanged(function()
    if AutoHatchToggle.Value then
        spawn(function()
            while AutoHatchToggle.Value do
                local selectedEgg = EggDropdown.Value
                local hatchMultiplier = HatchAmountDropdown.Value

                local args = {}

                if hatchMultiplier == "1x" then
                    args = {selectedEgg, nil, nil, false, nil}
                elseif hatchMultiplier == "3x" then
                    args = {selectedEgg, nil, true, false}
                elseif hatchMultiplier == "8x" then
                    args = {selectedEgg, nil, false, true, true}
                elseif hatchMultiplier == "30x" or hatchMultiplier == "Max" then
                    args = {selectedEgg, nil, nil, false, nil, true}
                end

                -- Invoke server call to hatch egg
                game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))

                wait(0.25)
            end
        end)
    end
end)

local TowerSection = Tabs.Tower:AddSection("Mining Tower")

-- Prison Cave Buttons
TowerSection:AddButton({
    Title = "Use Mining Keys (1x)",
    Description = "Use the Mining Key once.",
    Callback = function()
        local args = {
            [1] = "MiningTower",
            [2] = false
        }
        game:GetService("ReplicatedStorage").Packages.Knit.Services.TowerService.RF.EnterTower:InvokeServer(unpack(args))
    end
})

TowerSection:AddButton({
    Title = "Use All Mining Keys (250x)",
    Description = "Use All Mining Keys (max 250 at a time).",
    Callback = function()
        local args = {
            [1] = "MiningTower",
            [2] = true
        }
        game:GetService("ReplicatedStorage").Packages.Knit.Services.TowerService.RF.EnterTower:InvokeServer(unpack(args))
    end
})



-- Create SuperRB Section
local EventSection = Tabs.Merchant:AddSection("Individual Items")

-- Add Load Script Button
EventSection:AddButton({
    Title = "Load better Merchant script",
    Description = "This allows you to select individual items, but MAY cause lag.",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/SeperateMerchant/refs/heads/main/LessLag"))()
    end
})

local MerchantSection = Tabs.Merchant:AddSection("Mining Merchant")

local BlackMarketDropdown = Tabs.Merchant:AddDropdown("BlackMarketDropdown", {
    Title = "Select Merchant Slot(s)",
    Values = {1, 2, 3, 4, 5},
    Multi = true,
    Default = {}
})

local AutoBuyToggle = Tabs.Merchant:AddToggle("AutoBuyToggle", {
    Title = "Auto Buy (Selected Slots)",
    Default = false
})

AutoBuyToggle:OnChanged(function()
    if AutoBuyToggle.Value then
        spawn(function()
            while true do
                if not AutoBuyToggle.Value then break end
                -- Buy 3 times
                for i = 1, 3 do
                    for number, isSelected in pairs(BlackMarketDropdown.Value) do
                        if isSelected then
                            local args = {
                                [1] = "Mining Merchant",
                                [2] = number
                            }
                            game:GetService("ReplicatedStorage").Packages.Knit.Services.LimitedMerchantService.RF.BuyItem:InvokeServer(unpack(args))
                            wait(1)
                        end
                    end
                end
                wait(30) -- Wait 30 seconds before next cycle
            end
        end)
    end
end)


-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Wait for Knit
local Knit = require(ReplicatedStorage.Packages.Knit)
Knit.OnStart():await()

local MiningService = Knit.GetService("MiningService")
local blocksFolder = workspace.Zones.MinersDreamland.Interactables.Mining.Blocks
local mineSpawn = workspace.Zones.MinersDreamland.Interactables.Mining.MineSpawn
local timeLeftLabel = mineSpawn.Attachment.BillboardGui.TimeLeft

-- Get LayerInfo from the game module
local LayerInfoModule = require(ReplicatedStorage.Data.LayerInfo)

-- Mine reset handling variables
local isMinePaused = false
local mineResetCheckConnection
local lastCheckedTime = 0
local mineResetThreshold = 5 -- Stop mining when timer is under 5s
local mineRestartThreshold = 19 * 60 + 57 -- Restart mining when timer is under 19m 57s

local function ParseTimerText(timerText)
    if not timerText then return 0 end

    -- "MM:SS" format
    local minutes, seconds = timerText:match("(%d+):(%d+)")
    if minutes and seconds then
        return tonumber(minutes) * 60 + tonumber(seconds)
    end

    -- "Xm Ys" format
    local m, s = timerText:match("(%d+)m%s*(%d+)s")
    if m and s then
        return tonumber(m) * 60 + tonumber(s)
    end

    -- Fallback to 0 if parsing fails
    return 0
end


-- Extract all block names from the module, preserve order from LayerInfo
local function ExtractBlockNames()
    local blockNames = {}
    local blockSeen = {}
    
    for _, layerData in ipairs(LayerInfoModule) do
        for blockName in pairs(layerData.Spawnable) do
            if not blockSeen[blockName] then
                table.insert(blockNames, blockName)
                blockSeen[blockName] = true
            end
        end
    end
    
    return blockNames
end

-- Extract filtered blocks (no dirt/stone), preserve order from LayerInfo
local function ExtractBlockNamesFiltered()
    local blockNames = {}
    local blockSeen = {}
    
    for _, layerData in ipairs(LayerInfoModule) do
        for blockName in pairs(layerData.Spawnable) do
            local lowerName = string.lower(blockName)
            if lowerName ~= "dirt" and lowerName ~= "stone" and not blockSeen[blockName] then
                table.insert(blockNames, blockName)
                blockSeen[blockName] = true
            end
        end
    end
    
    return blockNames
end

local AllBlockNames = ExtractBlockNames()
local FilteredBlockNames = ExtractBlockNamesFiltered()

-- Mining variables
local selectedBlocks = {}
local miningEnabled = false
local miningConnection
local blocksTransparent = false
local transparencyConnection
local targetBlock = nil
local targetBlockMiningEnabled = false
local targetBlockMiningConnection
local pathMiningBlocks = {}
local mineAlongPath = false

local function CheckMineReset()
    if not timeLeftLabel then 
        timeLeftLabel = workspace.Zones.MinersDreamland.Interactables.Mining.MineSpawn.Attachment.BillboardGui.TimeLeft
        if not timeLeftLabel then return false end
    end

    local secondsLeft = ParseTimerText(timeLeftLabel.Text)

    -- Pause mining if below threshold
    if secondsLeft <= mineResetThreshold then
        return true
    end

    -- Resume mining if mine was paused and timer is above threshold
    if secondsLeft > mineResetThreshold and isMinePaused then
        return false, true
    end

    return false
end

-- Fix for transparency disconnect error

-- Function to toggle block transparency
local function ToggleBlockTransparency(transparent)
    blocksTransparent = transparent
    
    -- Always disconnect previous connection if it exists
    if transparencyConnection then
        pcall(function()
            transparencyConnection:Disconnect()
        end)
        transparencyConnection = nil
    end

    if transparent then
        transparencyConnection = task.spawn(function()
            while blocksTransparent do
                -- Safe check that blocks folder exists
                if blocksFolder and blocksFolder:IsDescendantOf(workspace) then
                    for _, block in ipairs(blocksFolder:GetChildren()) do
                        -- Safe check that Primary exists before changing transparency
                        if block and block:FindFirstChild("Primary") then
                            block.Primary.Transparency = 0.7
                        end
                    end
                else
                    -- Try to reconnect to blocks folder if it doesn't exist
                    pcall(function()
                        blocksFolder = workspace.Zones.MinersDreamland.Interactables.Mining.Blocks
                    end)
                end
                task.wait(3)
            end
        end)
    else
        -- Safe check when turning transparency off
        if blocksFolder and blocksFolder:IsDescendantOf(workspace) then
            for _, block in ipairs(blocksFolder:GetChildren()) do
                if block and block:FindFirstChild("Primary") then
                    block.Primary.Transparency = 0
                end
            end
        end
    end
end

-- Start monitoring mine reset timer
local function StartMineResetMonitoring()
    if mineResetCheckConnection then
        mineResetCheckConnection:Disconnect()
    end
    
    mineResetCheckConnection = RunService.Heartbeat:Connect(function()
        local shouldPause, hasReset = CheckMineReset()
        
        if shouldPause and not isMinePaused then
            -- Pause mining due to imminent reset
            isMinePaused = true
            print("Mining paused: Mine reset imminent")
        elseif not shouldPause and isMinePaused then
            -- Resume mining after reset
            isMinePaused = false
            print("Mining resumed: Mine reset complete")
        end
        
        if hasReset then
            -- Mine has just reset, recalculate everything
            print("Mine has reset - recalculating targets")
            if targetBlockMiningEnabled then
                StartTargetBlockMining()
            elseif miningEnabled then
                StartMining()
            end
            
            -- Toggle transparency off and back on if needed
            if blocksTransparent then
                ToggleBlockTransparency(false)
                ToggleBlockTransparency(true)
            end
        end
    end)
end


-- Function to verify if a block still exists
local function BlockExists(block)
    return block and block.Parent == blocksFolder
end

-- Get the block with the highest depth
local function GetHighestDepthBlock()
    -- Ensure blocks folder exists
    if not blocksFolder or not blocksFolder:IsDescendantOf(workspace) then
        blocksFolder = workspace.Zones.MinersDreamland.Interactables.Mining.Blocks
        if not blocksFolder then return nil end
    end
    
    local highestBlock = nil
    local highestDepth = -1
    for _, block in ipairs(blocksFolder:GetChildren()) do
        local depth = block:GetAttribute("Depth") or 0
        if depth > highestDepth then
            highestDepth = depth
            highestBlock = block
        end
    end
    return highestBlock
end
-- Check if block is valuable (not dirt or stone)
local function IsValuableBlock(blockName)
    local lowerName = string.lower(blockName)
    return not (lowerName == "dirt" or lowerName == "stone")
end

-- Find best block to mine based on multi-select
local function FindBestBlock()
    -- Ensure blocks folder exists
    if not blocksFolder or not blocksFolder:IsDescendantOf(workspace) then
        blocksFolder = workspace.Zones.MinersDreamland.Interactables.Mining.Blocks
        if not blocksFolder then return nil end
    end
    
    -- Check for selected blocks in view
    for _, block in ipairs(blocksFolder:GetChildren()) do
        for _, oreName in ipairs(selectedBlocks) do
            if string.find(string.lower(block.Name), string.lower(oreName)) then
                return block
            end
        end
    end

    -- If none found, mine the deepest block
    return GetHighestDepthBlock()
end

-- Mining loop
local function StartMining()
    if miningConnection then
        miningConnection:Disconnect()
    end
    
    miningConnection = RunService.Heartbeat:Connect(function()
        if not miningEnabled or isMinePaused then return end
        
        -- Ensure blocks folder exists after a mine reset
        if not blocksFolder or not blocksFolder:IsDescendantOf(workspace) then
            blocksFolder = workspace.Zones.MinersDreamland.Interactables.Mining.Blocks
            if not blocksFolder then return end
        end
        
        local blockToMine = FindBestBlock()
        if blockToMine and BlockExists(blockToMine) then
            MiningService:MineBlock(blockToMine):andThen(function() end)
        end
    end)
end

-- NEW: Independent path mining loop (Mine Along the Way)
local pathMiningConnection
local function StartPathMining()
    if pathMiningConnection then
        pathMiningConnection:Disconnect()
    end

    pathMiningConnection = RunService.Heartbeat:Connect(function()
        if not mineAlongPath or isMinePaused then return end
        
        if not blocksFolder or not blocksFolder:IsDescendantOf(workspace) then
            blocksFolder = workspace.Zones.MinersDreamland.Interactables.Mining.Blocks
            if not blocksFolder then return end
        end

        for _, block in ipairs(blocksFolder:GetChildren()) do
            local blockName = string.lower(block.Name)
            for _, targetName in ipairs(pathMiningBlocks) do
                if string.find(blockName, string.lower(targetName)) then
                    if BlockExists(block) then
                        MiningService:MineBlock(block):andThen(function() end)
                    end
                    return -- mine one block per frame
                end
            end
        end
    end)
end

-- Find the minimum depth at which a block appears
local function GetBlockMinDepth(blockName)
    for _, layerData in ipairs(LayerInfoModule) do
        if layerData.Spawnable and layerData.Spawnable[blockName] then
            return layerData.Depth or 0
        end
    end
    return 0
end

-- Get a block to mine when targeting a specific ore
local function GetBlockInTargetRange()
    if not targetBlock then 
        return GetHighestDepthBlock() 
    end
    
    if not blocksFolder or not blocksFolder:IsDescendantOf(workspace) then
        blocksFolder = workspace.Zones.MinersDreamland.Interactables.Mining.Blocks
        if not blocksFolder then return nil end
    end
    
    for _, block in ipairs(blocksFolder:GetChildren()) do
        if string.find(string.lower(block.Name), string.lower(targetBlock)) then
            return block
        end
    end
    
    -- Mine along the way is no longer tied here

    local targetMinDepth = GetBlockMinDepth(targetBlock)
    
    local bestBlock = nil
    local bestDepth = -1
    
    for _, block in ipairs(blocksFolder:GetChildren()) do
        local depth = block:GetAttribute("Depth") or 0
        if depth > bestDepth then
            bestDepth = depth
            bestBlock = block
        end
    end
    
    return bestBlock or GetHighestDepthBlock()
end

-- Target block mining loop
local function StartTargetBlockMining()
    if targetBlockMiningConnection then
        targetBlockMiningConnection:Disconnect()
    end
    
    targetBlockMiningConnection = RunService.Heartbeat:Connect(function()
        if not targetBlockMiningEnabled or isMinePaused then return end
        
        if not blocksFolder or not blocksFolder:IsDescendantOf(workspace) then
            blocksFolder = workspace.Zones.MinersDreamland.Interactables.Mining.Blocks
            if not blocksFolder then return end
        end
        
        local blockToMine = GetBlockInTargetRange()
        if blockToMine and BlockExists(blockToMine) then
            MiningService:MineBlock(blockToMine):andThen(function() end)
        end
    end)
end

-- UI Elements
local miningSection = Tabs.Mining:AddSection("Mining Controls")

local miningToggle = Tabs.Mining:AddToggle("MiningToggle", {
    Title = "Auto Mining",
    Default = false
})


local blockDropdown = Tabs.Mining:AddDropdown("BlockSelection", {
    Title = "Select Blocks to Mine",
    Values = AllBlockNames,
    Multi = true,
    Default = {},
    Searchable = true
})

blockDropdown:OnChanged(function(value)
    selectedBlocks = {}
    for block, selected in pairs(value) do
        if selected then
            table.insert(selectedBlocks, block)
        end
    end
end)

-- Target Block section
local targetSection = Tabs.Mining:AddSection("Target Block")

local targetBlockDropdown = Tabs.Mining:AddDropdown("TargetBlockSelection", {
    Title = "Target Ore",
    Values = AllBlockNames,
    Multi = false,
    Default = "",
    Searchable = true
})

targetBlockDropdown:OnChanged(function(value)
    targetBlock = value
end)

local pathMiningDropdown = Tabs.Mining:AddDropdown("PathMiningBlocks", {
    Title = "Mine Blocks Along the Way",
    Values = FilteredBlockNames,
    Multi = true,
    Default = {},
    Searchable = true
})

pathMiningDropdown:OnChanged(function(value)
    pathMiningBlocks = {}
    for block, selected in pairs(value) do
        if selected then
            table.insert(pathMiningBlocks, block)
        end
    end
end)

local pathMiningToggle = Tabs.Mining:AddToggle("PathMining", {
    Title = "Mine Along the Way",
    Default = false,
    Description = "Mine selected valuable blocks while digging around"
})

pathMiningToggle:OnChanged(function(value)
    mineAlongPath = value
    if value then
        StartPathMining()
    elseif pathMiningConnection then
        pathMiningConnection:Disconnect()
        pathMiningConnection = nil
    end
end)

local targetMiningToggle = Tabs.Mining:AddToggle("TargetMining", {
    Title = "Auto Mine to Target",
    Default = false,
    Description = "Automatically mine to reach target ore's depth"
})

targetMiningToggle:OnChanged(function(value)
    targetBlockMiningEnabled = value
    if value then
        if miningEnabled then
            miningToggle:SetValue(false)
        end
        StartTargetBlockMining()
    elseif targetBlockMiningConnection then
        targetBlockMiningConnection:Disconnect()
        targetBlockMiningConnection = nil
    end
end)

miningToggle:OnChanged(function(value)
    miningEnabled = value
    if value then
        if targetBlockMiningEnabled then
            targetMiningToggle:SetValue(false)
        end
        StartMining()
    elseif miningConnection then
        miningConnection:Disconnect()
        miningConnection = nil
    end
end)

-- Transparency section
local transparencySection = Tabs.Mining:AddSection("Transparency")

local transparencyToggle = Tabs.Mining:AddToggle("BlockTransparency", {
    Title = "Block Transparency",
    Default = false
})

transparencyToggle:OnChanged(function(value)
    ToggleBlockTransparency(value)
end)


-- Mine Reset Status section
local resetSection = Tabs.Mining:AddSection("Mine Reset Status")

local resetStatusLabel = resetSection:AddParagraph("ResetStatus", {
    Title = "Mine Reset Timer",
    Content = "Checking..."
})

-- Update reset status text continuously
spawn(function()
    while true do
        local success, text = pcall(function()
            if timeLeftLabel and timeLeftLabel:IsDescendantOf(workspace) then
                return timeLeftLabel.Text
            end
            return "Timer not found"
        end)
        
        if success then
            resetStatusLabel:SetContent("Mine Reset: " .. text)
        else
            resetStatusLabel:SetContent("Mine Reset: Error getting timer")
        end
        wait(1)
    end
end)

StartMineResetMonitoring()


-- Hand the library over to our managers
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes{}

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab("Settings")

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()


